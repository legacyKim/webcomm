
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Board
 * 
 */
export type Board = $Result.DefaultSelection<Prisma.$BoardPayload>
/**
 * Model Member
 * 
 */
export type Member = $Result.DefaultSelection<Prisma.$MemberPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model PostAction
 * 
 */
export type PostAction = $Result.DefaultSelection<Prisma.$PostActionPayload>
/**
 * Model CommentAction
 * 
 */
export type CommentAction = $Result.DefaultSelection<Prisma.$CommentActionPayload>
/**
 * Model PostImage
 * 
 */
export type PostImage = $Result.DefaultSelection<Prisma.$PostImagePayload>
/**
 * Model BlockedUser
 * 
 */
export type BlockedUser = $Result.DefaultSelection<Prisma.$BlockedUserPayload>
/**
 * Model UserReport
 * 
 */
export type UserReport = $Result.DefaultSelection<Prisma.$UserReportPayload>
/**
 * Model UserMessage
 * 
 */
export type UserMessage = $Result.DefaultSelection<Prisma.$UserMessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Boards
 * const boards = await prisma.board.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Boards
   * const boards = await prisma.board.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.board`: Exposes CRUD operations for the **Board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boards
    * const boards = await prisma.board.findMany()
    * ```
    */
  get board(): Prisma.BoardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **Member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.MemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postAction`: Exposes CRUD operations for the **PostAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostActions
    * const postActions = await prisma.postAction.findMany()
    * ```
    */
  get postAction(): Prisma.PostActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentAction`: Exposes CRUD operations for the **CommentAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentActions
    * const commentActions = await prisma.commentAction.findMany()
    * ```
    */
  get commentAction(): Prisma.CommentActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postImage`: Exposes CRUD operations for the **PostImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostImages
    * const postImages = await prisma.postImage.findMany()
    * ```
    */
  get postImage(): Prisma.PostImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blockedUser`: Exposes CRUD operations for the **BlockedUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedUsers
    * const blockedUsers = await prisma.blockedUser.findMany()
    * ```
    */
  get blockedUser(): Prisma.BlockedUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userReport`: Exposes CRUD operations for the **UserReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserReports
    * const userReports = await prisma.userReport.findMany()
    * ```
    */
  get userReport(): Prisma.UserReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userMessage`: Exposes CRUD operations for the **UserMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserMessages
    * const userMessages = await prisma.userMessage.findMany()
    * ```
    */
  get userMessage(): Prisma.UserMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Board: 'Board',
    Member: 'Member',
    Post: 'Post',
    Comment: 'Comment',
    PostAction: 'PostAction',
    CommentAction: 'CommentAction',
    PostImage: 'PostImage',
    BlockedUser: 'BlockedUser',
    UserReport: 'UserReport',
    UserMessage: 'UserMessage',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "board" | "member" | "post" | "comment" | "postAction" | "commentAction" | "postImage" | "blockedUser" | "userReport" | "userMessage" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Board: {
        payload: Prisma.$BoardPayload<ExtArgs>
        fields: Prisma.BoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findFirst: {
            args: Prisma.BoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          findMany: {
            args: Prisma.BoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          create: {
            args: Prisma.BoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          createMany: {
            args: Prisma.BoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BoardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          delete: {
            args: Prisma.BoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          update: {
            args: Prisma.BoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          deleteMany: {
            args: Prisma.BoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BoardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>[]
          }
          upsert: {
            args: Prisma.BoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BoardPayload>
          }
          aggregate: {
            args: Prisma.BoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoard>
          }
          groupBy: {
            args: Prisma.BoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.BoardCountArgs<ExtArgs>
            result: $Utils.Optional<BoardCountAggregateOutputType> | number
          }
        }
      }
      Member: {
        payload: Prisma.$MemberPayload<ExtArgs>
        fields: Prisma.MemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findFirst: {
            args: Prisma.MemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          findMany: {
            args: Prisma.MemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          create: {
            args: Prisma.MemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          createMany: {
            args: Prisma.MemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          delete: {
            args: Prisma.MemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          update: {
            args: Prisma.MemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          deleteMany: {
            args: Prisma.MemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>[]
          }
          upsert: {
            args: Prisma.MemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MemberPayload>
          }
          aggregate: {
            args: Prisma.MemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMember>
          }
          groupBy: {
            args: Prisma.MemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<MemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.MemberCountArgs<ExtArgs>
            result: $Utils.Optional<MemberCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      PostAction: {
        payload: Prisma.$PostActionPayload<ExtArgs>
        fields: Prisma.PostActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload>
          }
          findFirst: {
            args: Prisma.PostActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload>
          }
          findMany: {
            args: Prisma.PostActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload>[]
          }
          create: {
            args: Prisma.PostActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload>
          }
          createMany: {
            args: Prisma.PostActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload>[]
          }
          delete: {
            args: Prisma.PostActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload>
          }
          update: {
            args: Prisma.PostActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload>
          }
          deleteMany: {
            args: Prisma.PostActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload>[]
          }
          upsert: {
            args: Prisma.PostActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostActionPayload>
          }
          aggregate: {
            args: Prisma.PostActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostAction>
          }
          groupBy: {
            args: Prisma.PostActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostActionCountArgs<ExtArgs>
            result: $Utils.Optional<PostActionCountAggregateOutputType> | number
          }
        }
      }
      CommentAction: {
        payload: Prisma.$CommentActionPayload<ExtArgs>
        fields: Prisma.CommentActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload>
          }
          findFirst: {
            args: Prisma.CommentActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload>
          }
          findMany: {
            args: Prisma.CommentActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload>[]
          }
          create: {
            args: Prisma.CommentActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload>
          }
          createMany: {
            args: Prisma.CommentActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload>[]
          }
          delete: {
            args: Prisma.CommentActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload>
          }
          update: {
            args: Prisma.CommentActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload>
          }
          deleteMany: {
            args: Prisma.CommentActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload>[]
          }
          upsert: {
            args: Prisma.CommentActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentActionPayload>
          }
          aggregate: {
            args: Prisma.CommentActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentAction>
          }
          groupBy: {
            args: Prisma.CommentActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentActionCountArgs<ExtArgs>
            result: $Utils.Optional<CommentActionCountAggregateOutputType> | number
          }
        }
      }
      PostImage: {
        payload: Prisma.$PostImagePayload<ExtArgs>
        fields: Prisma.PostImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          findFirst: {
            args: Prisma.PostImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          findMany: {
            args: Prisma.PostImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>[]
          }
          create: {
            args: Prisma.PostImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          createMany: {
            args: Prisma.PostImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>[]
          }
          delete: {
            args: Prisma.PostImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          update: {
            args: Prisma.PostImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          deleteMany: {
            args: Prisma.PostImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>[]
          }
          upsert: {
            args: Prisma.PostImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostImagePayload>
          }
          aggregate: {
            args: Prisma.PostImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostImage>
          }
          groupBy: {
            args: Prisma.PostImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostImageCountArgs<ExtArgs>
            result: $Utils.Optional<PostImageCountAggregateOutputType> | number
          }
        }
      }
      BlockedUser: {
        payload: Prisma.$BlockedUserPayload<ExtArgs>
        fields: Prisma.BlockedUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockedUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockedUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findFirst: {
            args: Prisma.BlockedUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockedUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findMany: {
            args: Prisma.BlockedUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          create: {
            args: Prisma.BlockedUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          createMany: {
            args: Prisma.BlockedUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockedUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          delete: {
            args: Prisma.BlockedUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          update: {
            args: Prisma.BlockedUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          deleteMany: {
            args: Prisma.BlockedUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockedUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockedUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          upsert: {
            args: Prisma.BlockedUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          aggregate: {
            args: Prisma.BlockedUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockedUser>
          }
          groupBy: {
            args: Prisma.BlockedUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockedUserCountArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserCountAggregateOutputType> | number
          }
        }
      }
      UserReport: {
        payload: Prisma.$UserReportPayload<ExtArgs>
        fields: Prisma.UserReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload>
          }
          findFirst: {
            args: Prisma.UserReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload>
          }
          findMany: {
            args: Prisma.UserReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload>[]
          }
          create: {
            args: Prisma.UserReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload>
          }
          createMany: {
            args: Prisma.UserReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload>[]
          }
          delete: {
            args: Prisma.UserReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload>
          }
          update: {
            args: Prisma.UserReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload>
          }
          deleteMany: {
            args: Prisma.UserReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload>[]
          }
          upsert: {
            args: Prisma.UserReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserReportPayload>
          }
          aggregate: {
            args: Prisma.UserReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserReport>
          }
          groupBy: {
            args: Prisma.UserReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserReportCountArgs<ExtArgs>
            result: $Utils.Optional<UserReportCountAggregateOutputType> | number
          }
        }
      }
      UserMessage: {
        payload: Prisma.$UserMessagePayload<ExtArgs>
        fields: Prisma.UserMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload>
          }
          findFirst: {
            args: Prisma.UserMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload>
          }
          findMany: {
            args: Prisma.UserMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload>[]
          }
          create: {
            args: Prisma.UserMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload>
          }
          createMany: {
            args: Prisma.UserMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload>[]
          }
          delete: {
            args: Prisma.UserMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload>
          }
          update: {
            args: Prisma.UserMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload>
          }
          deleteMany: {
            args: Prisma.UserMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload>[]
          }
          upsert: {
            args: Prisma.UserMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserMessagePayload>
          }
          aggregate: {
            args: Prisma.UserMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserMessage>
          }
          groupBy: {
            args: Prisma.UserMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserMessageCountArgs<ExtArgs>
            result: $Utils.Optional<UserMessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    board?: BoardOmit
    member?: MemberOmit
    post?: PostOmit
    comment?: CommentOmit
    postAction?: PostActionOmit
    commentAction?: CommentActionOmit
    postImage?: PostImageOmit
    blockedUser?: BlockedUserOmit
    userReport?: UserReportOmit
    userMessage?: UserMessageOmit
    notification?: NotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BoardCountOutputType
   */

  export type BoardCountOutputType = {
    posts: number
  }

  export type BoardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | BoardCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardCountOutputType
     */
    select?: BoardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type MemberCountOutputType
   */

  export type MemberCountOutputType = {
    posts: number
    comments: number
    postActions: number
    commentActions: number
    blockedBy: number
    blockedUsers: number
    reportedBy: number
    reportedUsers: number
    sentMessages: number
    receivedMessages: number
    sentNotifications: number
    receivedNotifications: number
  }

  export type MemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | MemberCountOutputTypeCountPostsArgs
    comments?: boolean | MemberCountOutputTypeCountCommentsArgs
    postActions?: boolean | MemberCountOutputTypeCountPostActionsArgs
    commentActions?: boolean | MemberCountOutputTypeCountCommentActionsArgs
    blockedBy?: boolean | MemberCountOutputTypeCountBlockedByArgs
    blockedUsers?: boolean | MemberCountOutputTypeCountBlockedUsersArgs
    reportedBy?: boolean | MemberCountOutputTypeCountReportedByArgs
    reportedUsers?: boolean | MemberCountOutputTypeCountReportedUsersArgs
    sentMessages?: boolean | MemberCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | MemberCountOutputTypeCountReceivedMessagesArgs
    sentNotifications?: boolean | MemberCountOutputTypeCountSentNotificationsArgs
    receivedNotifications?: boolean | MemberCountOutputTypeCountReceivedNotificationsArgs
  }

  // Custom InputTypes
  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountPostActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostActionWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountCommentActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentActionWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountBlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountBlockedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountReportedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserReportWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountReportedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserReportWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMessageWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMessageWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountSentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeCountReceivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
    postActions: number
    images: number
    notifications: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    postActions?: boolean | PostCountOutputTypeCountPostActionsArgs
    images?: boolean | PostCountOutputTypeCountImagesArgs
    notifications?: boolean | PostCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPostActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostActionWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostImageWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
    actions: number
    notifications: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
    actions?: boolean | CommentCountOutputTypeCountActionsArgs
    notifications?: boolean | CommentCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentActionWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Board
   */

  export type AggregateBoard = {
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  export type BoardAvgAggregateOutputType = {
    id: number | null
    seq: number | null
  }

  export type BoardSumAggregateOutputType = {
    id: number | null
    seq: number | null
  }

  export type BoardMinAggregateOutputType = {
    id: number | null
    board_name: string | null
    url_slug: string | null
    seq: number | null
  }

  export type BoardMaxAggregateOutputType = {
    id: number | null
    board_name: string | null
    url_slug: string | null
    seq: number | null
  }

  export type BoardCountAggregateOutputType = {
    id: number
    board_name: number
    url_slug: number
    seq: number
    _all: number
  }


  export type BoardAvgAggregateInputType = {
    id?: true
    seq?: true
  }

  export type BoardSumAggregateInputType = {
    id?: true
    seq?: true
  }

  export type BoardMinAggregateInputType = {
    id?: true
    board_name?: true
    url_slug?: true
    seq?: true
  }

  export type BoardMaxAggregateInputType = {
    id?: true
    board_name?: true
    url_slug?: true
    seq?: true
  }

  export type BoardCountAggregateInputType = {
    id?: true
    board_name?: true
    url_slug?: true
    seq?: true
    _all?: true
  }

  export type BoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Board to aggregate.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boards
    **/
    _count?: true | BoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMaxAggregateInputType
  }

  export type GetBoardAggregateType<T extends BoardAggregateArgs> = {
        [P in keyof T & keyof AggregateBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoard[P]>
      : GetScalarType<T[P], AggregateBoard[P]>
  }




  export type BoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
    orderBy?: BoardOrderByWithAggregationInput | BoardOrderByWithAggregationInput[]
    by: BoardScalarFieldEnum[] | BoardScalarFieldEnum
    having?: BoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCountAggregateInputType | true
    _avg?: BoardAvgAggregateInputType
    _sum?: BoardSumAggregateInputType
    _min?: BoardMinAggregateInputType
    _max?: BoardMaxAggregateInputType
  }

  export type BoardGroupByOutputType = {
    id: number
    board_name: string
    url_slug: string
    seq: number
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  type GetBoardGroupByPayload<T extends BoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardGroupByOutputType[P]>
            : GetScalarType<T[P], BoardGroupByOutputType[P]>
        }
      >
    >


  export type BoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_name?: boolean
    url_slug?: boolean
    seq?: boolean
    posts?: boolean | Board$postsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_name?: boolean
    url_slug?: boolean
    seq?: boolean
  }, ExtArgs["result"]["board"]>

  export type BoardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_name?: boolean
    url_slug?: boolean
    seq?: boolean
  }, ExtArgs["result"]["board"]>

  export type BoardSelectScalar = {
    id?: boolean
    board_name?: boolean
    url_slug?: boolean
    seq?: boolean
  }

  export type BoardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "board_name" | "url_slug" | "seq", ExtArgs["result"]["board"]>
  export type BoardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Board$postsArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BoardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BoardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Board"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      board_name: string
      url_slug: string
      seq: number
    }, ExtArgs["result"]["board"]>
    composites: {}
  }

  type BoardGetPayload<S extends boolean | null | undefined | BoardDefaultArgs> = $Result.GetResult<Prisma.$BoardPayload, S>

  type BoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BoardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoardCountAggregateInputType | true
    }

  export interface BoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Board'], meta: { name: 'Board' } }
    /**
     * Find zero or one Board that matches the filter.
     * @param {BoardFindUniqueArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BoardFindUniqueArgs>(args: SelectSubset<T, BoardFindUniqueArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Board that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BoardFindUniqueOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BoardFindUniqueOrThrowArgs>(args: SelectSubset<T, BoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BoardFindFirstArgs>(args?: SelectSubset<T, BoardFindFirstArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Board that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BoardFindFirstOrThrowArgs>(args?: SelectSubset<T, BoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boards
     * const boards = await prisma.board.findMany()
     * 
     * // Get first 10 Boards
     * const boards = await prisma.board.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardWithIdOnly = await prisma.board.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BoardFindManyArgs>(args?: SelectSubset<T, BoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Board.
     * @param {BoardCreateArgs} args - Arguments to create a Board.
     * @example
     * // Create one Board
     * const Board = await prisma.board.create({
     *   data: {
     *     // ... data to create a Board
     *   }
     * })
     * 
     */
    create<T extends BoardCreateArgs>(args: SelectSubset<T, BoardCreateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boards.
     * @param {BoardCreateManyArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BoardCreateManyArgs>(args?: SelectSubset<T, BoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boards and returns the data saved in the database.
     * @param {BoardCreateManyAndReturnArgs} args - Arguments to create many Boards.
     * @example
     * // Create many Boards
     * const board = await prisma.board.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BoardCreateManyAndReturnArgs>(args?: SelectSubset<T, BoardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Board.
     * @param {BoardDeleteArgs} args - Arguments to delete one Board.
     * @example
     * // Delete one Board
     * const Board = await prisma.board.delete({
     *   where: {
     *     // ... filter to delete one Board
     *   }
     * })
     * 
     */
    delete<T extends BoardDeleteArgs>(args: SelectSubset<T, BoardDeleteArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Board.
     * @param {BoardUpdateArgs} args - Arguments to update one Board.
     * @example
     * // Update one Board
     * const board = await prisma.board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BoardUpdateArgs>(args: SelectSubset<T, BoardUpdateArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boards.
     * @param {BoardDeleteManyArgs} args - Arguments to filter Boards to delete.
     * @example
     * // Delete a few Boards
     * const { count } = await prisma.board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BoardDeleteManyArgs>(args?: SelectSubset<T, BoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BoardUpdateManyArgs>(args: SelectSubset<T, BoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards and returns the data updated in the database.
     * @param {BoardUpdateManyAndReturnArgs} args - Arguments to update many Boards.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boards and only return the `id`
     * const boardWithIdOnly = await prisma.board.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BoardUpdateManyAndReturnArgs>(args: SelectSubset<T, BoardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Board.
     * @param {BoardUpsertArgs} args - Arguments to update or create a Board.
     * @example
     * // Update or create a Board
     * const board = await prisma.board.upsert({
     *   create: {
     *     // ... data to create a Board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Board we want to update
     *   }
     * })
     */
    upsert<T extends BoardUpsertArgs>(args: SelectSubset<T, BoardUpsertArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCountArgs} args - Arguments to filter Boards to count.
     * @example
     * // Count the number of Boards
     * const count = await prisma.board.count({
     *   where: {
     *     // ... the filter for the Boards we want to count
     *   }
     * })
    **/
    count<T extends BoardCountArgs>(
      args?: Subset<T, BoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardAggregateArgs>(args: Subset<T, BoardAggregateArgs>): Prisma.PrismaPromise<GetBoardAggregateType<T>>

    /**
     * Group by Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardGroupByArgs['orderBy'] }
        : { orderBy?: BoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Board model
   */
  readonly fields: BoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Board$postsArgs<ExtArgs> = {}>(args?: Subset<T, Board$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Board model
   */
  interface BoardFieldRefs {
    readonly id: FieldRef<"Board", 'Int'>
    readonly board_name: FieldRef<"Board", 'String'>
    readonly url_slug: FieldRef<"Board", 'String'>
    readonly seq: FieldRef<"Board", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Board findUnique
   */
  export type BoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findUniqueOrThrow
   */
  export type BoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findFirst
   */
  export type BoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findFirstOrThrow
   */
  export type BoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board findMany
   */
  export type BoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Boards to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: BoardOrderByWithRelationInput | BoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    distinct?: BoardScalarFieldEnum | BoardScalarFieldEnum[]
  }

  /**
   * Board create
   */
  export type BoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to create a Board.
     */
    data: XOR<BoardCreateInput, BoardUncheckedCreateInput>
  }

  /**
   * Board createMany
   */
  export type BoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Board createManyAndReturn
   */
  export type BoardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to create many Boards.
     */
    data: BoardCreateManyInput | BoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Board update
   */
  export type BoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to update a Board.
     */
    data: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
    /**
     * Choose, which Board to update.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board updateMany
   */
  export type BoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
  }

  /**
   * Board updateManyAndReturn
   */
  export type BoardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to update.
     */
    limit?: number
  }

  /**
   * Board upsert
   */
  export type BoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The filter to search for the Board to update in case it exists.
     */
    where: BoardWhereUniqueInput
    /**
     * In case the Board found by the `where` argument doesn't exist, create a new Board with this data.
     */
    create: XOR<BoardCreateInput, BoardUncheckedCreateInput>
    /**
     * In case the Board was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
  }

  /**
   * Board delete
   */
  export type BoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter which Board to delete.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board deleteMany
   */
  export type BoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boards to delete
     */
    where?: BoardWhereInput
    /**
     * Limit how many Boards to delete.
     */
    limit?: number
  }

  /**
   * Board.posts
   */
  export type Board$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Board without action
   */
  export type BoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Board
     */
    omit?: BoardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BoardInclude<ExtArgs> | null
  }


  /**
   * Model Member
   */

  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    id: number | null
    all_posts: number | null
    authority: number | null
    all_views: number | null
  }

  export type MemberSumAggregateOutputType = {
    id: number | null
    all_posts: number | null
    authority: number | null
    all_views: number | null
  }

  export type MemberMinAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    all_posts: number | null
    authority: number | null
    all_views: number | null
    password: string | null
    user_nickname: string | null
    profile: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberMaxAggregateOutputType = {
    id: number | null
    username: string | null
    email: string | null
    all_posts: number | null
    authority: number | null
    all_views: number | null
    password: string | null
    user_nickname: string | null
    profile: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    username: number
    email: number
    all_posts: number
    authority: number
    all_views: number
    password: number
    user_nickname: number
    profile: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    id?: true
    all_posts?: true
    authority?: true
    all_views?: true
  }

  export type MemberSumAggregateInputType = {
    id?: true
    all_posts?: true
    authority?: true
    all_views?: true
  }

  export type MemberMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    all_posts?: true
    authority?: true
    all_views?: true
    password?: true
    user_nickname?: true
    profile?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    all_posts?: true
    authority?: true
    all_views?: true
    password?: true
    user_nickname?: true
    profile?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    all_posts?: true
    authority?: true
    all_views?: true
    password?: true
    user_nickname?: true
    profile?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Member to aggregate.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MemberWhereInput
    orderBy?: MemberOrderByWithAggregationInput | MemberOrderByWithAggregationInput[]
    by: MemberScalarFieldEnum[] | MemberScalarFieldEnum
    having?: MemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }

  export type MemberGroupByOutputType = {
    id: number
    username: string
    email: string
    all_posts: number
    authority: number
    all_views: number
    password: string
    user_nickname: string | null
    profile: string | null
    createdAt: Date
    updatedAt: Date
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type MemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    all_posts?: boolean
    authority?: boolean
    all_views?: boolean
    password?: boolean
    user_nickname?: boolean
    profile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | Member$postsArgs<ExtArgs>
    comments?: boolean | Member$commentsArgs<ExtArgs>
    postActions?: boolean | Member$postActionsArgs<ExtArgs>
    commentActions?: boolean | Member$commentActionsArgs<ExtArgs>
    blockedBy?: boolean | Member$blockedByArgs<ExtArgs>
    blockedUsers?: boolean | Member$blockedUsersArgs<ExtArgs>
    reportedBy?: boolean | Member$reportedByArgs<ExtArgs>
    reportedUsers?: boolean | Member$reportedUsersArgs<ExtArgs>
    sentMessages?: boolean | Member$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | Member$receivedMessagesArgs<ExtArgs>
    sentNotifications?: boolean | Member$sentNotificationsArgs<ExtArgs>
    receivedNotifications?: boolean | Member$receivedNotificationsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["member"]>

  export type MemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    all_posts?: boolean
    authority?: boolean
    all_views?: boolean
    password?: boolean
    user_nickname?: boolean
    profile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["member"]>

  export type MemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    all_posts?: boolean
    authority?: boolean
    all_views?: boolean
    password?: boolean
    user_nickname?: boolean
    profile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["member"]>

  export type MemberSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    all_posts?: boolean
    authority?: boolean
    all_views?: boolean
    password?: boolean
    user_nickname?: boolean
    profile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "all_posts" | "authority" | "all_views" | "password" | "user_nickname" | "profile" | "createdAt" | "updatedAt", ExtArgs["result"]["member"]>
  export type MemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Member$postsArgs<ExtArgs>
    comments?: boolean | Member$commentsArgs<ExtArgs>
    postActions?: boolean | Member$postActionsArgs<ExtArgs>
    commentActions?: boolean | Member$commentActionsArgs<ExtArgs>
    blockedBy?: boolean | Member$blockedByArgs<ExtArgs>
    blockedUsers?: boolean | Member$blockedUsersArgs<ExtArgs>
    reportedBy?: boolean | Member$reportedByArgs<ExtArgs>
    reportedUsers?: boolean | Member$reportedUsersArgs<ExtArgs>
    sentMessages?: boolean | Member$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | Member$receivedMessagesArgs<ExtArgs>
    sentNotifications?: boolean | Member$sentNotificationsArgs<ExtArgs>
    receivedNotifications?: boolean | Member$receivedNotificationsArgs<ExtArgs>
    _count?: boolean | MemberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Member"
    objects: {
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      postActions: Prisma.$PostActionPayload<ExtArgs>[]
      commentActions: Prisma.$CommentActionPayload<ExtArgs>[]
      blockedBy: Prisma.$BlockedUserPayload<ExtArgs>[]
      blockedUsers: Prisma.$BlockedUserPayload<ExtArgs>[]
      reportedBy: Prisma.$UserReportPayload<ExtArgs>[]
      reportedUsers: Prisma.$UserReportPayload<ExtArgs>[]
      sentMessages: Prisma.$UserMessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$UserMessagePayload<ExtArgs>[]
      sentNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      receivedNotifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      email: string
      all_posts: number
      authority: number
      all_views: number
      password: string
      user_nickname: string | null
      profile: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["member"]>
    composites: {}
  }

  type MemberGetPayload<S extends boolean | null | undefined | MemberDefaultArgs> = $Result.GetResult<Prisma.$MemberPayload, S>

  type MemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface MemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Member'], meta: { name: 'Member' } }
    /**
     * Find zero or one Member that matches the filter.
     * @param {MemberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MemberFindUniqueArgs>(args: SelectSubset<T, MemberFindUniqueArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MemberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MemberFindUniqueOrThrowArgs>(args: SelectSubset<T, MemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MemberFindFirstArgs>(args?: SelectSubset<T, MemberFindFirstArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MemberFindFirstOrThrowArgs>(args?: SelectSubset<T, MemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MemberFindManyArgs>(args?: SelectSubset<T, MemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Member.
     * @param {MemberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
     */
    create<T extends MemberCreateArgs>(args: SelectSubset<T, MemberCreateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Members.
     * @param {MemberCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MemberCreateManyArgs>(args?: SelectSubset<T, MemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MemberCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const member = await prisma.member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MemberCreateManyAndReturnArgs>(args?: SelectSubset<T, MemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Member.
     * @param {MemberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
     */
    delete<T extends MemberDeleteArgs>(args: SelectSubset<T, MemberDeleteArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Member.
     * @param {MemberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MemberUpdateArgs>(args: SelectSubset<T, MemberUpdateArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Members.
     * @param {MemberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MemberDeleteManyArgs>(args?: SelectSubset<T, MemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MemberUpdateManyArgs>(args: SelectSubset<T, MemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members and returns the data updated in the database.
     * @param {MemberUpdateManyAndReturnArgs} args - Arguments to update many Members.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Members and only return the `id`
     * const memberWithIdOnly = await prisma.member.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MemberUpdateManyAndReturnArgs>(args: SelectSubset<T, MemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Member.
     * @param {MemberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
     */
    upsert<T extends MemberUpsertArgs>(args: SelectSubset<T, MemberUpsertArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MemberCountArgs>(
      args?: Subset<T, MemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Member model
   */
  readonly fields: MemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Member$postsArgs<ExtArgs> = {}>(args?: Subset<T, Member$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Member$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Member$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postActions<T extends Member$postActionsArgs<ExtArgs> = {}>(args?: Subset<T, Member$postActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentActions<T extends Member$commentActionsArgs<ExtArgs> = {}>(args?: Subset<T, Member$commentActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blockedBy<T extends Member$blockedByArgs<ExtArgs> = {}>(args?: Subset<T, Member$blockedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blockedUsers<T extends Member$blockedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Member$blockedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedBy<T extends Member$reportedByArgs<ExtArgs> = {}>(args?: Subset<T, Member$reportedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportedUsers<T extends Member$reportedUsersArgs<ExtArgs> = {}>(args?: Subset<T, Member$reportedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends Member$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Member$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends Member$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Member$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentNotifications<T extends Member$sentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Member$sentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedNotifications<T extends Member$receivedNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, Member$receivedNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Member model
   */
  interface MemberFieldRefs {
    readonly id: FieldRef<"Member", 'Int'>
    readonly username: FieldRef<"Member", 'String'>
    readonly email: FieldRef<"Member", 'String'>
    readonly all_posts: FieldRef<"Member", 'Int'>
    readonly authority: FieldRef<"Member", 'Int'>
    readonly all_views: FieldRef<"Member", 'Int'>
    readonly password: FieldRef<"Member", 'String'>
    readonly user_nickname: FieldRef<"Member", 'String'>
    readonly profile: FieldRef<"Member", 'String'>
    readonly createdAt: FieldRef<"Member", 'DateTime'>
    readonly updatedAt: FieldRef<"Member", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Member findUnique
   */
  export type MemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findUniqueOrThrow
   */
  export type MemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member findFirst
   */
  export type MemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findFirstOrThrow
   */
  export type MemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Member to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member findMany
   */
  export type MemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MemberOrderByWithRelationInput | MemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MemberScalarFieldEnum | MemberScalarFieldEnum[]
  }

  /**
   * Member create
   */
  export type MemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to create a Member.
     */
    data: XOR<MemberCreateInput, MemberUncheckedCreateInput>
  }

  /**
   * Member createMany
   */
  export type MemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member createManyAndReturn
   */
  export type MemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MemberCreateManyInput | MemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Member update
   */
  export type MemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The data needed to update a Member.
     */
    data: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
    /**
     * Choose, which Member to update.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member updateMany
   */
  export type MemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member updateManyAndReturn
   */
  export type MemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * The data used to update Members.
     */
    data: XOR<MemberUpdateManyMutationInput, MemberUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to update.
     */
    limit?: number
  }

  /**
   * Member upsert
   */
  export type MemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * The filter to search for the Member to update in case it exists.
     */
    where: MemberWhereUniqueInput
    /**
     * In case the Member found by the `where` argument doesn't exist, create a new Member with this data.
     */
    create: XOR<MemberCreateInput, MemberUncheckedCreateInput>
    /**
     * In case the Member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MemberUpdateInput, MemberUncheckedUpdateInput>
  }

  /**
   * Member delete
   */
  export type MemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
    /**
     * Filter which Member to delete.
     */
    where: MemberWhereUniqueInput
  }

  /**
   * Member deleteMany
   */
  export type MemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MemberWhereInput
    /**
     * Limit how many Members to delete.
     */
    limit?: number
  }

  /**
   * Member.posts
   */
  export type Member$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Member.comments
   */
  export type Member$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Member.postActions
   */
  export type Member$postActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    where?: PostActionWhereInput
    orderBy?: PostActionOrderByWithRelationInput | PostActionOrderByWithRelationInput[]
    cursor?: PostActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostActionScalarFieldEnum | PostActionScalarFieldEnum[]
  }

  /**
   * Member.commentActions
   */
  export type Member$commentActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    where?: CommentActionWhereInput
    orderBy?: CommentActionOrderByWithRelationInput | CommentActionOrderByWithRelationInput[]
    cursor?: CommentActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentActionScalarFieldEnum | CommentActionScalarFieldEnum[]
  }

  /**
   * Member.blockedBy
   */
  export type Member$blockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    cursor?: BlockedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * Member.blockedUsers
   */
  export type Member$blockedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    cursor?: BlockedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * Member.reportedBy
   */
  export type Member$reportedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    where?: UserReportWhereInput
    orderBy?: UserReportOrderByWithRelationInput | UserReportOrderByWithRelationInput[]
    cursor?: UserReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserReportScalarFieldEnum | UserReportScalarFieldEnum[]
  }

  /**
   * Member.reportedUsers
   */
  export type Member$reportedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    where?: UserReportWhereInput
    orderBy?: UserReportOrderByWithRelationInput | UserReportOrderByWithRelationInput[]
    cursor?: UserReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserReportScalarFieldEnum | UserReportScalarFieldEnum[]
  }

  /**
   * Member.sentMessages
   */
  export type Member$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    where?: UserMessageWhereInput
    orderBy?: UserMessageOrderByWithRelationInput | UserMessageOrderByWithRelationInput[]
    cursor?: UserMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMessageScalarFieldEnum | UserMessageScalarFieldEnum[]
  }

  /**
   * Member.receivedMessages
   */
  export type Member$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    where?: UserMessageWhereInput
    orderBy?: UserMessageOrderByWithRelationInput | UserMessageOrderByWithRelationInput[]
    cursor?: UserMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserMessageScalarFieldEnum | UserMessageScalarFieldEnum[]
  }

  /**
   * Member.sentNotifications
   */
  export type Member$sentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Member.receivedNotifications
   */
  export type Member$receivedNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Member without action
   */
  export type MemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Member
     */
    select?: MemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Member
     */
    omit?: MemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MemberInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    board_id: number | null
    user_id: number | null
    views: number | null
    likes: number | null
    dislikes: number | null
    reports: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    board_id: number | null
    user_id: number | null
    views: number | null
    likes: number | null
    dislikes: number | null
    reports: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    board_id: number | null
    board_name: string | null
    title: string | null
    content: string | null
    user_id: number | null
    views: number | null
    likes: number | null
    dislikes: number | null
    reports: number | null
    created_at: Date | null
    updated_at: Date | null
    url_slug: string | null
    user_nickname: string | null
    is_deleted: boolean | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    board_id: number | null
    board_name: string | null
    title: string | null
    content: string | null
    user_id: number | null
    views: number | null
    likes: number | null
    dislikes: number | null
    reports: number | null
    created_at: Date | null
    updated_at: Date | null
    url_slug: string | null
    user_nickname: string | null
    is_deleted: boolean | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    board_id: number
    board_name: number
    title: number
    content: number
    user_id: number
    views: number
    likes: number
    dislikes: number
    reports: number
    created_at: number
    updated_at: number
    url_slug: number
    user_nickname: number
    is_deleted: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    board_id?: true
    user_id?: true
    views?: true
    likes?: true
    dislikes?: true
    reports?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    board_id?: true
    user_id?: true
    views?: true
    likes?: true
    dislikes?: true
    reports?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    board_id?: true
    board_name?: true
    title?: true
    content?: true
    user_id?: true
    views?: true
    likes?: true
    dislikes?: true
    reports?: true
    created_at?: true
    updated_at?: true
    url_slug?: true
    user_nickname?: true
    is_deleted?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    board_id?: true
    board_name?: true
    title?: true
    content?: true
    user_id?: true
    views?: true
    likes?: true
    dislikes?: true
    reports?: true
    created_at?: true
    updated_at?: true
    url_slug?: true
    user_nickname?: true
    is_deleted?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    board_id?: true
    board_name?: true
    title?: true
    content?: true
    user_id?: true
    views?: true
    likes?: true
    dislikes?: true
    reports?: true
    created_at?: true
    updated_at?: true
    url_slug?: true
    user_nickname?: true
    is_deleted?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    board_id: number
    board_name: string
    title: string
    content: string
    user_id: number
    views: number
    likes: number
    dislikes: number
    reports: number
    created_at: Date
    updated_at: Date
    url_slug: string
    user_nickname: string | null
    is_deleted: boolean
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_id?: boolean
    board_name?: boolean
    title?: boolean
    content?: boolean
    user_id?: boolean
    views?: boolean
    likes?: boolean
    dislikes?: boolean
    reports?: boolean
    created_at?: boolean
    updated_at?: boolean
    url_slug?: boolean
    user_nickname?: boolean
    is_deleted?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    postActions?: boolean | Post$postActionsArgs<ExtArgs>
    images?: boolean | Post$imagesArgs<ExtArgs>
    notifications?: boolean | Post$notificationsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_id?: boolean
    board_name?: boolean
    title?: boolean
    content?: boolean
    user_id?: boolean
    views?: boolean
    likes?: boolean
    dislikes?: boolean
    reports?: boolean
    created_at?: boolean
    updated_at?: boolean
    url_slug?: boolean
    user_nickname?: boolean
    is_deleted?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    board_id?: boolean
    board_name?: boolean
    title?: boolean
    content?: boolean
    user_id?: boolean
    views?: boolean
    likes?: boolean
    dislikes?: boolean
    reports?: boolean
    created_at?: boolean
    updated_at?: boolean
    url_slug?: boolean
    user_nickname?: boolean
    is_deleted?: boolean
    board?: boolean | BoardDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    board_id?: boolean
    board_name?: boolean
    title?: boolean
    content?: boolean
    user_id?: boolean
    views?: boolean
    likes?: boolean
    dislikes?: boolean
    reports?: boolean
    created_at?: boolean
    updated_at?: boolean
    url_slug?: boolean
    user_nickname?: boolean
    is_deleted?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "board_id" | "board_name" | "title" | "content" | "user_id" | "views" | "likes" | "dislikes" | "reports" | "created_at" | "updated_at" | "url_slug" | "user_nickname" | "is_deleted", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    postActions?: boolean | Post$postActionsArgs<ExtArgs>
    images?: boolean | Post$imagesArgs<ExtArgs>
    notifications?: boolean | Post$notificationsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    board?: boolean | BoardDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      board: Prisma.$BoardPayload<ExtArgs>
      author: Prisma.$MemberPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      postActions: Prisma.$PostActionPayload<ExtArgs>[]
      images: Prisma.$PostImagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      board_id: number
      board_name: string
      title: string
      content: string
      user_id: number
      views: number
      likes: number
      dislikes: number
      reports: number
      created_at: Date
      updated_at: Date
      url_slug: string
      user_nickname: string | null
      is_deleted: boolean
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    board<T extends BoardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BoardDefaultArgs<ExtArgs>>): Prisma__BoardClient<$Result.GetResult<Prisma.$BoardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postActions<T extends Post$postActionsArgs<ExtArgs> = {}>(args?: Subset<T, Post$postActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends Post$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Post$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Post$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Post$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly board_id: FieldRef<"Post", 'Int'>
    readonly board_name: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly user_id: FieldRef<"Post", 'Int'>
    readonly views: FieldRef<"Post", 'Int'>
    readonly likes: FieldRef<"Post", 'Int'>
    readonly dislikes: FieldRef<"Post", 'Int'>
    readonly reports: FieldRef<"Post", 'Int'>
    readonly created_at: FieldRef<"Post", 'DateTime'>
    readonly updated_at: FieldRef<"Post", 'DateTime'>
    readonly url_slug: FieldRef<"Post", 'String'>
    readonly user_nickname: FieldRef<"Post", 'String'>
    readonly is_deleted: FieldRef<"Post", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.postActions
   */
  export type Post$postActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    where?: PostActionWhereInput
    orderBy?: PostActionOrderByWithRelationInput | PostActionOrderByWithRelationInput[]
    cursor?: PostActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostActionScalarFieldEnum | PostActionScalarFieldEnum[]
  }

  /**
   * Post.images
   */
  export type Post$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    where?: PostImageWhereInput
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    cursor?: PostImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * Post.notifications
   */
  export type Post$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
    parent_id: number | null
    likes: number | null
    dislikes: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
    parent_id: number | null
    likes: number | null
    dislikes: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
    content: string | null
    parent_id: number | null
    created_at: Date | null
    updated_at: Date | null
    likes: number | null
    dislikes: number | null
    user_nickname: string | null
    is_deleted: boolean | null
    deleted_at: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
    content: string | null
    parent_id: number | null
    created_at: Date | null
    updated_at: Date | null
    likes: number | null
    dislikes: number | null
    user_nickname: string | null
    is_deleted: boolean | null
    deleted_at: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    post_id: number
    user_id: number
    content: number
    parent_id: number
    created_at: number
    updated_at: number
    likes: number
    dislikes: number
    user_nickname: number
    is_deleted: number
    deleted_at: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    parent_id?: true
    likes?: true
    dislikes?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    parent_id?: true
    likes?: true
    dislikes?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    content?: true
    parent_id?: true
    created_at?: true
    updated_at?: true
    likes?: true
    dislikes?: true
    user_nickname?: true
    is_deleted?: true
    deleted_at?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    content?: true
    parent_id?: true
    created_at?: true
    updated_at?: true
    likes?: true
    dislikes?: true
    user_nickname?: true
    is_deleted?: true
    deleted_at?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    content?: true
    parent_id?: true
    created_at?: true
    updated_at?: true
    likes?: true
    dislikes?: true
    user_nickname?: true
    is_deleted?: true
    deleted_at?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    post_id: number
    user_id: number
    content: string
    parent_id: number | null
    created_at: Date
    updated_at: Date
    likes: number
    dislikes: number
    user_nickname: string | null
    is_deleted: boolean
    deleted_at: Date | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    parent_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    likes?: boolean
    dislikes?: boolean
    user_nickname?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    actions?: boolean | Comment$actionsArgs<ExtArgs>
    notifications?: boolean | Comment$notificationsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    parent_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    likes?: boolean
    dislikes?: boolean
    user_nickname?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    parent_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    likes?: boolean
    dislikes?: boolean
    user_nickname?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    parent_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    likes?: boolean
    dislikes?: boolean
    user_nickname?: boolean
    is_deleted?: boolean
    deleted_at?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "post_id" | "user_id" | "content" | "parent_id" | "created_at" | "updated_at" | "likes" | "dislikes" | "user_nickname" | "is_deleted" | "deleted_at", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    actions?: boolean | Comment$actionsArgs<ExtArgs>
    notifications?: boolean | Comment$notificationsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | MemberDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      author: Prisma.$MemberPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
      actions: Prisma.$CommentActionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      post_id: number
      user_id: number
      content: string
      parent_id: number | null
      created_at: Date
      updated_at: Date
      likes: number
      dislikes: number
      user_nickname: string | null
      is_deleted: boolean
      deleted_at: Date | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actions<T extends Comment$actionsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Comment$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly post_id: FieldRef<"Comment", 'Int'>
    readonly user_id: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly parent_id: FieldRef<"Comment", 'Int'>
    readonly created_at: FieldRef<"Comment", 'DateTime'>
    readonly updated_at: FieldRef<"Comment", 'DateTime'>
    readonly likes: FieldRef<"Comment", 'Int'>
    readonly dislikes: FieldRef<"Comment", 'Int'>
    readonly user_nickname: FieldRef<"Comment", 'String'>
    readonly is_deleted: FieldRef<"Comment", 'Boolean'>
    readonly deleted_at: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.actions
   */
  export type Comment$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    where?: CommentActionWhereInput
    orderBy?: CommentActionOrderByWithRelationInput | CommentActionOrderByWithRelationInput[]
    cursor?: CommentActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentActionScalarFieldEnum | CommentActionScalarFieldEnum[]
  }

  /**
   * Comment.notifications
   */
  export type Comment$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model PostAction
   */

  export type AggregatePostAction = {
    _count: PostActionCountAggregateOutputType | null
    _avg: PostActionAvgAggregateOutputType | null
    _sum: PostActionSumAggregateOutputType | null
    _min: PostActionMinAggregateOutputType | null
    _max: PostActionMaxAggregateOutputType | null
  }

  export type PostActionAvgAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type PostActionSumAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type PostActionMinAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
    action_type: string | null
    created_at: Date | null
  }

  export type PostActionMaxAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
    action_type: string | null
    created_at: Date | null
  }

  export type PostActionCountAggregateOutputType = {
    id: number
    post_id: number
    user_id: number
    action_type: number
    created_at: number
    _all: number
  }


  export type PostActionAvgAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
  }

  export type PostActionSumAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
  }

  export type PostActionMinAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    action_type?: true
    created_at?: true
  }

  export type PostActionMaxAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    action_type?: true
    created_at?: true
  }

  export type PostActionCountAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    action_type?: true
    created_at?: true
    _all?: true
  }

  export type PostActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostAction to aggregate.
     */
    where?: PostActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostActions to fetch.
     */
    orderBy?: PostActionOrderByWithRelationInput | PostActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostActions
    **/
    _count?: true | PostActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostActionMaxAggregateInputType
  }

  export type GetPostActionAggregateType<T extends PostActionAggregateArgs> = {
        [P in keyof T & keyof AggregatePostAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostAction[P]>
      : GetScalarType<T[P], AggregatePostAction[P]>
  }




  export type PostActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostActionWhereInput
    orderBy?: PostActionOrderByWithAggregationInput | PostActionOrderByWithAggregationInput[]
    by: PostActionScalarFieldEnum[] | PostActionScalarFieldEnum
    having?: PostActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostActionCountAggregateInputType | true
    _avg?: PostActionAvgAggregateInputType
    _sum?: PostActionSumAggregateInputType
    _min?: PostActionMinAggregateInputType
    _max?: PostActionMaxAggregateInputType
  }

  export type PostActionGroupByOutputType = {
    id: number
    post_id: number
    user_id: number
    action_type: string
    created_at: Date
    _count: PostActionCountAggregateOutputType | null
    _avg: PostActionAvgAggregateOutputType | null
    _sum: PostActionSumAggregateOutputType | null
    _min: PostActionMinAggregateOutputType | null
    _max: PostActionMaxAggregateOutputType | null
  }

  type GetPostActionGroupByPayload<T extends PostActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostActionGroupByOutputType[P]>
            : GetScalarType<T[P], PostActionGroupByOutputType[P]>
        }
      >
    >


  export type PostActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    action_type?: boolean
    created_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAction"]>

  export type PostActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    action_type?: boolean
    created_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAction"]>

  export type PostActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    action_type?: boolean
    created_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postAction"]>

  export type PostActionSelectScalar = {
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    action_type?: boolean
    created_at?: boolean
  }

  export type PostActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "post_id" | "user_id" | "action_type" | "created_at", ExtArgs["result"]["postAction"]>
  export type PostActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type PostActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type PostActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $PostActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostAction"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      user: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      post_id: number
      user_id: number
      action_type: string
      created_at: Date
    }, ExtArgs["result"]["postAction"]>
    composites: {}
  }

  type PostActionGetPayload<S extends boolean | null | undefined | PostActionDefaultArgs> = $Result.GetResult<Prisma.$PostActionPayload, S>

  type PostActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostActionCountAggregateInputType | true
    }

  export interface PostActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostAction'], meta: { name: 'PostAction' } }
    /**
     * Find zero or one PostAction that matches the filter.
     * @param {PostActionFindUniqueArgs} args - Arguments to find a PostAction
     * @example
     * // Get one PostAction
     * const postAction = await prisma.postAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostActionFindUniqueArgs>(args: SelectSubset<T, PostActionFindUniqueArgs<ExtArgs>>): Prisma__PostActionClient<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostActionFindUniqueOrThrowArgs} args - Arguments to find a PostAction
     * @example
     * // Get one PostAction
     * const postAction = await prisma.postAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostActionFindUniqueOrThrowArgs>(args: SelectSubset<T, PostActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostActionClient<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostActionFindFirstArgs} args - Arguments to find a PostAction
     * @example
     * // Get one PostAction
     * const postAction = await prisma.postAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostActionFindFirstArgs>(args?: SelectSubset<T, PostActionFindFirstArgs<ExtArgs>>): Prisma__PostActionClient<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostActionFindFirstOrThrowArgs} args - Arguments to find a PostAction
     * @example
     * // Get one PostAction
     * const postAction = await prisma.postAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostActionFindFirstOrThrowArgs>(args?: SelectSubset<T, PostActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostActionClient<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostActions
     * const postActions = await prisma.postAction.findMany()
     * 
     * // Get first 10 PostActions
     * const postActions = await prisma.postAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postActionWithIdOnly = await prisma.postAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostActionFindManyArgs>(args?: SelectSubset<T, PostActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostAction.
     * @param {PostActionCreateArgs} args - Arguments to create a PostAction.
     * @example
     * // Create one PostAction
     * const PostAction = await prisma.postAction.create({
     *   data: {
     *     // ... data to create a PostAction
     *   }
     * })
     * 
     */
    create<T extends PostActionCreateArgs>(args: SelectSubset<T, PostActionCreateArgs<ExtArgs>>): Prisma__PostActionClient<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostActions.
     * @param {PostActionCreateManyArgs} args - Arguments to create many PostActions.
     * @example
     * // Create many PostActions
     * const postAction = await prisma.postAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostActionCreateManyArgs>(args?: SelectSubset<T, PostActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostActions and returns the data saved in the database.
     * @param {PostActionCreateManyAndReturnArgs} args - Arguments to create many PostActions.
     * @example
     * // Create many PostActions
     * const postAction = await prisma.postAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostActions and only return the `id`
     * const postActionWithIdOnly = await prisma.postAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostActionCreateManyAndReturnArgs>(args?: SelectSubset<T, PostActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostAction.
     * @param {PostActionDeleteArgs} args - Arguments to delete one PostAction.
     * @example
     * // Delete one PostAction
     * const PostAction = await prisma.postAction.delete({
     *   where: {
     *     // ... filter to delete one PostAction
     *   }
     * })
     * 
     */
    delete<T extends PostActionDeleteArgs>(args: SelectSubset<T, PostActionDeleteArgs<ExtArgs>>): Prisma__PostActionClient<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostAction.
     * @param {PostActionUpdateArgs} args - Arguments to update one PostAction.
     * @example
     * // Update one PostAction
     * const postAction = await prisma.postAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostActionUpdateArgs>(args: SelectSubset<T, PostActionUpdateArgs<ExtArgs>>): Prisma__PostActionClient<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostActions.
     * @param {PostActionDeleteManyArgs} args - Arguments to filter PostActions to delete.
     * @example
     * // Delete a few PostActions
     * const { count } = await prisma.postAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostActionDeleteManyArgs>(args?: SelectSubset<T, PostActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostActions
     * const postAction = await prisma.postAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostActionUpdateManyArgs>(args: SelectSubset<T, PostActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostActions and returns the data updated in the database.
     * @param {PostActionUpdateManyAndReturnArgs} args - Arguments to update many PostActions.
     * @example
     * // Update many PostActions
     * const postAction = await prisma.postAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostActions and only return the `id`
     * const postActionWithIdOnly = await prisma.postAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostActionUpdateManyAndReturnArgs>(args: SelectSubset<T, PostActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostAction.
     * @param {PostActionUpsertArgs} args - Arguments to update or create a PostAction.
     * @example
     * // Update or create a PostAction
     * const postAction = await prisma.postAction.upsert({
     *   create: {
     *     // ... data to create a PostAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostAction we want to update
     *   }
     * })
     */
    upsert<T extends PostActionUpsertArgs>(args: SelectSubset<T, PostActionUpsertArgs<ExtArgs>>): Prisma__PostActionClient<$Result.GetResult<Prisma.$PostActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostActionCountArgs} args - Arguments to filter PostActions to count.
     * @example
     * // Count the number of PostActions
     * const count = await prisma.postAction.count({
     *   where: {
     *     // ... the filter for the PostActions we want to count
     *   }
     * })
    **/
    count<T extends PostActionCountArgs>(
      args?: Subset<T, PostActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostActionAggregateArgs>(args: Subset<T, PostActionAggregateArgs>): Prisma.PrismaPromise<GetPostActionAggregateType<T>>

    /**
     * Group by PostAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostActionGroupByArgs['orderBy'] }
        : { orderBy?: PostActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostAction model
   */
  readonly fields: PostActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostAction model
   */
  interface PostActionFieldRefs {
    readonly id: FieldRef<"PostAction", 'Int'>
    readonly post_id: FieldRef<"PostAction", 'Int'>
    readonly user_id: FieldRef<"PostAction", 'Int'>
    readonly action_type: FieldRef<"PostAction", 'String'>
    readonly created_at: FieldRef<"PostAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostAction findUnique
   */
  export type PostActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    /**
     * Filter, which PostAction to fetch.
     */
    where: PostActionWhereUniqueInput
  }

  /**
   * PostAction findUniqueOrThrow
   */
  export type PostActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    /**
     * Filter, which PostAction to fetch.
     */
    where: PostActionWhereUniqueInput
  }

  /**
   * PostAction findFirst
   */
  export type PostActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    /**
     * Filter, which PostAction to fetch.
     */
    where?: PostActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostActions to fetch.
     */
    orderBy?: PostActionOrderByWithRelationInput | PostActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostActions.
     */
    cursor?: PostActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostActions.
     */
    distinct?: PostActionScalarFieldEnum | PostActionScalarFieldEnum[]
  }

  /**
   * PostAction findFirstOrThrow
   */
  export type PostActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    /**
     * Filter, which PostAction to fetch.
     */
    where?: PostActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostActions to fetch.
     */
    orderBy?: PostActionOrderByWithRelationInput | PostActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostActions.
     */
    cursor?: PostActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostActions.
     */
    distinct?: PostActionScalarFieldEnum | PostActionScalarFieldEnum[]
  }

  /**
   * PostAction findMany
   */
  export type PostActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    /**
     * Filter, which PostActions to fetch.
     */
    where?: PostActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostActions to fetch.
     */
    orderBy?: PostActionOrderByWithRelationInput | PostActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostActions.
     */
    cursor?: PostActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostActions.
     */
    skip?: number
    distinct?: PostActionScalarFieldEnum | PostActionScalarFieldEnum[]
  }

  /**
   * PostAction create
   */
  export type PostActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    /**
     * The data needed to create a PostAction.
     */
    data: XOR<PostActionCreateInput, PostActionUncheckedCreateInput>
  }

  /**
   * PostAction createMany
   */
  export type PostActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostActions.
     */
    data: PostActionCreateManyInput | PostActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostAction createManyAndReturn
   */
  export type PostActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * The data used to create many PostActions.
     */
    data: PostActionCreateManyInput | PostActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostAction update
   */
  export type PostActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    /**
     * The data needed to update a PostAction.
     */
    data: XOR<PostActionUpdateInput, PostActionUncheckedUpdateInput>
    /**
     * Choose, which PostAction to update.
     */
    where: PostActionWhereUniqueInput
  }

  /**
   * PostAction updateMany
   */
  export type PostActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostActions.
     */
    data: XOR<PostActionUpdateManyMutationInput, PostActionUncheckedUpdateManyInput>
    /**
     * Filter which PostActions to update
     */
    where?: PostActionWhereInput
    /**
     * Limit how many PostActions to update.
     */
    limit?: number
  }

  /**
   * PostAction updateManyAndReturn
   */
  export type PostActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * The data used to update PostActions.
     */
    data: XOR<PostActionUpdateManyMutationInput, PostActionUncheckedUpdateManyInput>
    /**
     * Filter which PostActions to update
     */
    where?: PostActionWhereInput
    /**
     * Limit how many PostActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostAction upsert
   */
  export type PostActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    /**
     * The filter to search for the PostAction to update in case it exists.
     */
    where: PostActionWhereUniqueInput
    /**
     * In case the PostAction found by the `where` argument doesn't exist, create a new PostAction with this data.
     */
    create: XOR<PostActionCreateInput, PostActionUncheckedCreateInput>
    /**
     * In case the PostAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostActionUpdateInput, PostActionUncheckedUpdateInput>
  }

  /**
   * PostAction delete
   */
  export type PostActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
    /**
     * Filter which PostAction to delete.
     */
    where: PostActionWhereUniqueInput
  }

  /**
   * PostAction deleteMany
   */
  export type PostActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostActions to delete
     */
    where?: PostActionWhereInput
    /**
     * Limit how many PostActions to delete.
     */
    limit?: number
  }

  /**
   * PostAction without action
   */
  export type PostActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostAction
     */
    select?: PostActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostAction
     */
    omit?: PostActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostActionInclude<ExtArgs> | null
  }


  /**
   * Model CommentAction
   */

  export type AggregateCommentAction = {
    _count: CommentActionCountAggregateOutputType | null
    _avg: CommentActionAvgAggregateOutputType | null
    _sum: CommentActionSumAggregateOutputType | null
    _min: CommentActionMinAggregateOutputType | null
    _max: CommentActionMaxAggregateOutputType | null
  }

  export type CommentActionAvgAggregateOutputType = {
    id: number | null
    comment_id: number | null
    user_id: number | null
  }

  export type CommentActionSumAggregateOutputType = {
    id: number | null
    comment_id: number | null
    user_id: number | null
  }

  export type CommentActionMinAggregateOutputType = {
    id: number | null
    comment_id: number | null
    user_id: number | null
    action_type: string | null
    reason: string | null
    created_at: Date | null
  }

  export type CommentActionMaxAggregateOutputType = {
    id: number | null
    comment_id: number | null
    user_id: number | null
    action_type: string | null
    reason: string | null
    created_at: Date | null
  }

  export type CommentActionCountAggregateOutputType = {
    id: number
    comment_id: number
    user_id: number
    action_type: number
    reason: number
    created_at: number
    _all: number
  }


  export type CommentActionAvgAggregateInputType = {
    id?: true
    comment_id?: true
    user_id?: true
  }

  export type CommentActionSumAggregateInputType = {
    id?: true
    comment_id?: true
    user_id?: true
  }

  export type CommentActionMinAggregateInputType = {
    id?: true
    comment_id?: true
    user_id?: true
    action_type?: true
    reason?: true
    created_at?: true
  }

  export type CommentActionMaxAggregateInputType = {
    id?: true
    comment_id?: true
    user_id?: true
    action_type?: true
    reason?: true
    created_at?: true
  }

  export type CommentActionCountAggregateInputType = {
    id?: true
    comment_id?: true
    user_id?: true
    action_type?: true
    reason?: true
    created_at?: true
    _all?: true
  }

  export type CommentActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentAction to aggregate.
     */
    where?: CommentActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentActions to fetch.
     */
    orderBy?: CommentActionOrderByWithRelationInput | CommentActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentActions
    **/
    _count?: true | CommentActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentActionMaxAggregateInputType
  }

  export type GetCommentActionAggregateType<T extends CommentActionAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentAction[P]>
      : GetScalarType<T[P], AggregateCommentAction[P]>
  }




  export type CommentActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentActionWhereInput
    orderBy?: CommentActionOrderByWithAggregationInput | CommentActionOrderByWithAggregationInput[]
    by: CommentActionScalarFieldEnum[] | CommentActionScalarFieldEnum
    having?: CommentActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentActionCountAggregateInputType | true
    _avg?: CommentActionAvgAggregateInputType
    _sum?: CommentActionSumAggregateInputType
    _min?: CommentActionMinAggregateInputType
    _max?: CommentActionMaxAggregateInputType
  }

  export type CommentActionGroupByOutputType = {
    id: number
    comment_id: number
    user_id: number
    action_type: string
    reason: string | null
    created_at: Date
    _count: CommentActionCountAggregateOutputType | null
    _avg: CommentActionAvgAggregateOutputType | null
    _sum: CommentActionSumAggregateOutputType | null
    _min: CommentActionMinAggregateOutputType | null
    _max: CommentActionMaxAggregateOutputType | null
  }

  type GetCommentActionGroupByPayload<T extends CommentActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentActionGroupByOutputType[P]>
            : GetScalarType<T[P], CommentActionGroupByOutputType[P]>
        }
      >
    >


  export type CommentActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comment_id?: boolean
    user_id?: boolean
    action_type?: boolean
    reason?: boolean
    created_at?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentAction"]>

  export type CommentActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comment_id?: boolean
    user_id?: boolean
    action_type?: boolean
    reason?: boolean
    created_at?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentAction"]>

  export type CommentActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comment_id?: boolean
    user_id?: boolean
    action_type?: boolean
    reason?: boolean
    created_at?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentAction"]>

  export type CommentActionSelectScalar = {
    id?: boolean
    comment_id?: boolean
    user_id?: boolean
    action_type?: boolean
    reason?: boolean
    created_at?: boolean
  }

  export type CommentActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "comment_id" | "user_id" | "action_type" | "reason" | "created_at", ExtArgs["result"]["commentAction"]>
  export type CommentActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type CommentActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type CommentActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $CommentActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentAction"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      user: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      comment_id: number
      user_id: number
      action_type: string
      reason: string | null
      created_at: Date
    }, ExtArgs["result"]["commentAction"]>
    composites: {}
  }

  type CommentActionGetPayload<S extends boolean | null | undefined | CommentActionDefaultArgs> = $Result.GetResult<Prisma.$CommentActionPayload, S>

  type CommentActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentActionCountAggregateInputType | true
    }

  export interface CommentActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentAction'], meta: { name: 'CommentAction' } }
    /**
     * Find zero or one CommentAction that matches the filter.
     * @param {CommentActionFindUniqueArgs} args - Arguments to find a CommentAction
     * @example
     * // Get one CommentAction
     * const commentAction = await prisma.commentAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentActionFindUniqueArgs>(args: SelectSubset<T, CommentActionFindUniqueArgs<ExtArgs>>): Prisma__CommentActionClient<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentActionFindUniqueOrThrowArgs} args - Arguments to find a CommentAction
     * @example
     * // Get one CommentAction
     * const commentAction = await prisma.commentAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentActionFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentActionClient<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentActionFindFirstArgs} args - Arguments to find a CommentAction
     * @example
     * // Get one CommentAction
     * const commentAction = await prisma.commentAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentActionFindFirstArgs>(args?: SelectSubset<T, CommentActionFindFirstArgs<ExtArgs>>): Prisma__CommentActionClient<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentActionFindFirstOrThrowArgs} args - Arguments to find a CommentAction
     * @example
     * // Get one CommentAction
     * const commentAction = await prisma.commentAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentActionFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentActionClient<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentActions
     * const commentActions = await prisma.commentAction.findMany()
     * 
     * // Get first 10 CommentActions
     * const commentActions = await prisma.commentAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentActionWithIdOnly = await prisma.commentAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentActionFindManyArgs>(args?: SelectSubset<T, CommentActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentAction.
     * @param {CommentActionCreateArgs} args - Arguments to create a CommentAction.
     * @example
     * // Create one CommentAction
     * const CommentAction = await prisma.commentAction.create({
     *   data: {
     *     // ... data to create a CommentAction
     *   }
     * })
     * 
     */
    create<T extends CommentActionCreateArgs>(args: SelectSubset<T, CommentActionCreateArgs<ExtArgs>>): Prisma__CommentActionClient<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentActions.
     * @param {CommentActionCreateManyArgs} args - Arguments to create many CommentActions.
     * @example
     * // Create many CommentActions
     * const commentAction = await prisma.commentAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentActionCreateManyArgs>(args?: SelectSubset<T, CommentActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentActions and returns the data saved in the database.
     * @param {CommentActionCreateManyAndReturnArgs} args - Arguments to create many CommentActions.
     * @example
     * // Create many CommentActions
     * const commentAction = await prisma.commentAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentActions and only return the `id`
     * const commentActionWithIdOnly = await prisma.commentAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentActionCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentAction.
     * @param {CommentActionDeleteArgs} args - Arguments to delete one CommentAction.
     * @example
     * // Delete one CommentAction
     * const CommentAction = await prisma.commentAction.delete({
     *   where: {
     *     // ... filter to delete one CommentAction
     *   }
     * })
     * 
     */
    delete<T extends CommentActionDeleteArgs>(args: SelectSubset<T, CommentActionDeleteArgs<ExtArgs>>): Prisma__CommentActionClient<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentAction.
     * @param {CommentActionUpdateArgs} args - Arguments to update one CommentAction.
     * @example
     * // Update one CommentAction
     * const commentAction = await prisma.commentAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentActionUpdateArgs>(args: SelectSubset<T, CommentActionUpdateArgs<ExtArgs>>): Prisma__CommentActionClient<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentActions.
     * @param {CommentActionDeleteManyArgs} args - Arguments to filter CommentActions to delete.
     * @example
     * // Delete a few CommentActions
     * const { count } = await prisma.commentAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentActionDeleteManyArgs>(args?: SelectSubset<T, CommentActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentActions
     * const commentAction = await prisma.commentAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentActionUpdateManyArgs>(args: SelectSubset<T, CommentActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentActions and returns the data updated in the database.
     * @param {CommentActionUpdateManyAndReturnArgs} args - Arguments to update many CommentActions.
     * @example
     * // Update many CommentActions
     * const commentAction = await prisma.commentAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentActions and only return the `id`
     * const commentActionWithIdOnly = await prisma.commentAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentActionUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentAction.
     * @param {CommentActionUpsertArgs} args - Arguments to update or create a CommentAction.
     * @example
     * // Update or create a CommentAction
     * const commentAction = await prisma.commentAction.upsert({
     *   create: {
     *     // ... data to create a CommentAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentAction we want to update
     *   }
     * })
     */
    upsert<T extends CommentActionUpsertArgs>(args: SelectSubset<T, CommentActionUpsertArgs<ExtArgs>>): Prisma__CommentActionClient<$Result.GetResult<Prisma.$CommentActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentActionCountArgs} args - Arguments to filter CommentActions to count.
     * @example
     * // Count the number of CommentActions
     * const count = await prisma.commentAction.count({
     *   where: {
     *     // ... the filter for the CommentActions we want to count
     *   }
     * })
    **/
    count<T extends CommentActionCountArgs>(
      args?: Subset<T, CommentActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentActionAggregateArgs>(args: Subset<T, CommentActionAggregateArgs>): Prisma.PrismaPromise<GetCommentActionAggregateType<T>>

    /**
     * Group by CommentAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentActionGroupByArgs['orderBy'] }
        : { orderBy?: CommentActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentAction model
   */
  readonly fields: CommentActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentAction model
   */
  interface CommentActionFieldRefs {
    readonly id: FieldRef<"CommentAction", 'Int'>
    readonly comment_id: FieldRef<"CommentAction", 'Int'>
    readonly user_id: FieldRef<"CommentAction", 'Int'>
    readonly action_type: FieldRef<"CommentAction", 'String'>
    readonly reason: FieldRef<"CommentAction", 'String'>
    readonly created_at: FieldRef<"CommentAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommentAction findUnique
   */
  export type CommentActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    /**
     * Filter, which CommentAction to fetch.
     */
    where: CommentActionWhereUniqueInput
  }

  /**
   * CommentAction findUniqueOrThrow
   */
  export type CommentActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    /**
     * Filter, which CommentAction to fetch.
     */
    where: CommentActionWhereUniqueInput
  }

  /**
   * CommentAction findFirst
   */
  export type CommentActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    /**
     * Filter, which CommentAction to fetch.
     */
    where?: CommentActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentActions to fetch.
     */
    orderBy?: CommentActionOrderByWithRelationInput | CommentActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentActions.
     */
    cursor?: CommentActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentActions.
     */
    distinct?: CommentActionScalarFieldEnum | CommentActionScalarFieldEnum[]
  }

  /**
   * CommentAction findFirstOrThrow
   */
  export type CommentActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    /**
     * Filter, which CommentAction to fetch.
     */
    where?: CommentActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentActions to fetch.
     */
    orderBy?: CommentActionOrderByWithRelationInput | CommentActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentActions.
     */
    cursor?: CommentActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentActions.
     */
    distinct?: CommentActionScalarFieldEnum | CommentActionScalarFieldEnum[]
  }

  /**
   * CommentAction findMany
   */
  export type CommentActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    /**
     * Filter, which CommentActions to fetch.
     */
    where?: CommentActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentActions to fetch.
     */
    orderBy?: CommentActionOrderByWithRelationInput | CommentActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentActions.
     */
    cursor?: CommentActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentActions.
     */
    skip?: number
    distinct?: CommentActionScalarFieldEnum | CommentActionScalarFieldEnum[]
  }

  /**
   * CommentAction create
   */
  export type CommentActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentAction.
     */
    data: XOR<CommentActionCreateInput, CommentActionUncheckedCreateInput>
  }

  /**
   * CommentAction createMany
   */
  export type CommentActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentActions.
     */
    data: CommentActionCreateManyInput | CommentActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentAction createManyAndReturn
   */
  export type CommentActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * The data used to create many CommentActions.
     */
    data: CommentActionCreateManyInput | CommentActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentAction update
   */
  export type CommentActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentAction.
     */
    data: XOR<CommentActionUpdateInput, CommentActionUncheckedUpdateInput>
    /**
     * Choose, which CommentAction to update.
     */
    where: CommentActionWhereUniqueInput
  }

  /**
   * CommentAction updateMany
   */
  export type CommentActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentActions.
     */
    data: XOR<CommentActionUpdateManyMutationInput, CommentActionUncheckedUpdateManyInput>
    /**
     * Filter which CommentActions to update
     */
    where?: CommentActionWhereInput
    /**
     * Limit how many CommentActions to update.
     */
    limit?: number
  }

  /**
   * CommentAction updateManyAndReturn
   */
  export type CommentActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * The data used to update CommentActions.
     */
    data: XOR<CommentActionUpdateManyMutationInput, CommentActionUncheckedUpdateManyInput>
    /**
     * Filter which CommentActions to update
     */
    where?: CommentActionWhereInput
    /**
     * Limit how many CommentActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentAction upsert
   */
  export type CommentActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentAction to update in case it exists.
     */
    where: CommentActionWhereUniqueInput
    /**
     * In case the CommentAction found by the `where` argument doesn't exist, create a new CommentAction with this data.
     */
    create: XOR<CommentActionCreateInput, CommentActionUncheckedCreateInput>
    /**
     * In case the CommentAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentActionUpdateInput, CommentActionUncheckedUpdateInput>
  }

  /**
   * CommentAction delete
   */
  export type CommentActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
    /**
     * Filter which CommentAction to delete.
     */
    where: CommentActionWhereUniqueInput
  }

  /**
   * CommentAction deleteMany
   */
  export type CommentActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentActions to delete
     */
    where?: CommentActionWhereInput
    /**
     * Limit how many CommentActions to delete.
     */
    limit?: number
  }

  /**
   * CommentAction without action
   */
  export type CommentActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentAction
     */
    select?: CommentActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentAction
     */
    omit?: CommentActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentActionInclude<ExtArgs> | null
  }


  /**
   * Model PostImage
   */

  export type AggregatePostImage = {
    _count: PostImageCountAggregateOutputType | null
    _avg: PostImageAvgAggregateOutputType | null
    _sum: PostImageSumAggregateOutputType | null
    _min: PostImageMinAggregateOutputType | null
    _max: PostImageMaxAggregateOutputType | null
  }

  export type PostImageAvgAggregateOutputType = {
    id: number | null
    post_id: number | null
  }

  export type PostImageSumAggregateOutputType = {
    id: number | null
    post_id: number | null
  }

  export type PostImageMinAggregateOutputType = {
    id: number | null
    post_id: number | null
    image_url: string | null
    created_at: Date | null
  }

  export type PostImageMaxAggregateOutputType = {
    id: number | null
    post_id: number | null
    image_url: string | null
    created_at: Date | null
  }

  export type PostImageCountAggregateOutputType = {
    id: number
    post_id: number
    image_url: number
    created_at: number
    _all: number
  }


  export type PostImageAvgAggregateInputType = {
    id?: true
    post_id?: true
  }

  export type PostImageSumAggregateInputType = {
    id?: true
    post_id?: true
  }

  export type PostImageMinAggregateInputType = {
    id?: true
    post_id?: true
    image_url?: true
    created_at?: true
  }

  export type PostImageMaxAggregateInputType = {
    id?: true
    post_id?: true
    image_url?: true
    created_at?: true
  }

  export type PostImageCountAggregateInputType = {
    id?: true
    post_id?: true
    image_url?: true
    created_at?: true
    _all?: true
  }

  export type PostImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostImage to aggregate.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostImages
    **/
    _count?: true | PostImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostImageMaxAggregateInputType
  }

  export type GetPostImageAggregateType<T extends PostImageAggregateArgs> = {
        [P in keyof T & keyof AggregatePostImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostImage[P]>
      : GetScalarType<T[P], AggregatePostImage[P]>
  }




  export type PostImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostImageWhereInput
    orderBy?: PostImageOrderByWithAggregationInput | PostImageOrderByWithAggregationInput[]
    by: PostImageScalarFieldEnum[] | PostImageScalarFieldEnum
    having?: PostImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostImageCountAggregateInputType | true
    _avg?: PostImageAvgAggregateInputType
    _sum?: PostImageSumAggregateInputType
    _min?: PostImageMinAggregateInputType
    _max?: PostImageMaxAggregateInputType
  }

  export type PostImageGroupByOutputType = {
    id: number
    post_id: number
    image_url: string
    created_at: Date
    _count: PostImageCountAggregateOutputType | null
    _avg: PostImageAvgAggregateOutputType | null
    _sum: PostImageSumAggregateOutputType | null
    _min: PostImageMinAggregateOutputType | null
    _max: PostImageMaxAggregateOutputType | null
  }

  type GetPostImageGroupByPayload<T extends PostImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostImageGroupByOutputType[P]>
            : GetScalarType<T[P], PostImageGroupByOutputType[P]>
        }
      >
    >


  export type PostImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    image_url?: boolean
    created_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postImage"]>

  export type PostImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    image_url?: boolean
    created_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postImage"]>

  export type PostImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    image_url?: boolean
    created_at?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postImage"]>

  export type PostImageSelectScalar = {
    id?: boolean
    post_id?: boolean
    image_url?: boolean
    created_at?: boolean
  }

  export type PostImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "post_id" | "image_url" | "created_at", ExtArgs["result"]["postImage"]>
  export type PostImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type PostImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $PostImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostImage"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      post_id: number
      image_url: string
      created_at: Date
    }, ExtArgs["result"]["postImage"]>
    composites: {}
  }

  type PostImageGetPayload<S extends boolean | null | undefined | PostImageDefaultArgs> = $Result.GetResult<Prisma.$PostImagePayload, S>

  type PostImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostImageCountAggregateInputType | true
    }

  export interface PostImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostImage'], meta: { name: 'PostImage' } }
    /**
     * Find zero or one PostImage that matches the filter.
     * @param {PostImageFindUniqueArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostImageFindUniqueArgs>(args: SelectSubset<T, PostImageFindUniqueArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostImageFindUniqueOrThrowArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostImageFindUniqueOrThrowArgs>(args: SelectSubset<T, PostImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageFindFirstArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostImageFindFirstArgs>(args?: SelectSubset<T, PostImageFindFirstArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageFindFirstOrThrowArgs} args - Arguments to find a PostImage
     * @example
     * // Get one PostImage
     * const postImage = await prisma.postImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostImageFindFirstOrThrowArgs>(args?: SelectSubset<T, PostImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostImages
     * const postImages = await prisma.postImage.findMany()
     * 
     * // Get first 10 PostImages
     * const postImages = await prisma.postImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postImageWithIdOnly = await prisma.postImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostImageFindManyArgs>(args?: SelectSubset<T, PostImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostImage.
     * @param {PostImageCreateArgs} args - Arguments to create a PostImage.
     * @example
     * // Create one PostImage
     * const PostImage = await prisma.postImage.create({
     *   data: {
     *     // ... data to create a PostImage
     *   }
     * })
     * 
     */
    create<T extends PostImageCreateArgs>(args: SelectSubset<T, PostImageCreateArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostImages.
     * @param {PostImageCreateManyArgs} args - Arguments to create many PostImages.
     * @example
     * // Create many PostImages
     * const postImage = await prisma.postImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostImageCreateManyArgs>(args?: SelectSubset<T, PostImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostImages and returns the data saved in the database.
     * @param {PostImageCreateManyAndReturnArgs} args - Arguments to create many PostImages.
     * @example
     * // Create many PostImages
     * const postImage = await prisma.postImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostImages and only return the `id`
     * const postImageWithIdOnly = await prisma.postImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostImageCreateManyAndReturnArgs>(args?: SelectSubset<T, PostImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostImage.
     * @param {PostImageDeleteArgs} args - Arguments to delete one PostImage.
     * @example
     * // Delete one PostImage
     * const PostImage = await prisma.postImage.delete({
     *   where: {
     *     // ... filter to delete one PostImage
     *   }
     * })
     * 
     */
    delete<T extends PostImageDeleteArgs>(args: SelectSubset<T, PostImageDeleteArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostImage.
     * @param {PostImageUpdateArgs} args - Arguments to update one PostImage.
     * @example
     * // Update one PostImage
     * const postImage = await prisma.postImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostImageUpdateArgs>(args: SelectSubset<T, PostImageUpdateArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostImages.
     * @param {PostImageDeleteManyArgs} args - Arguments to filter PostImages to delete.
     * @example
     * // Delete a few PostImages
     * const { count } = await prisma.postImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostImageDeleteManyArgs>(args?: SelectSubset<T, PostImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostImages
     * const postImage = await prisma.postImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostImageUpdateManyArgs>(args: SelectSubset<T, PostImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostImages and returns the data updated in the database.
     * @param {PostImageUpdateManyAndReturnArgs} args - Arguments to update many PostImages.
     * @example
     * // Update many PostImages
     * const postImage = await prisma.postImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostImages and only return the `id`
     * const postImageWithIdOnly = await prisma.postImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostImageUpdateManyAndReturnArgs>(args: SelectSubset<T, PostImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostImage.
     * @param {PostImageUpsertArgs} args - Arguments to update or create a PostImage.
     * @example
     * // Update or create a PostImage
     * const postImage = await prisma.postImage.upsert({
     *   create: {
     *     // ... data to create a PostImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostImage we want to update
     *   }
     * })
     */
    upsert<T extends PostImageUpsertArgs>(args: SelectSubset<T, PostImageUpsertArgs<ExtArgs>>): Prisma__PostImageClient<$Result.GetResult<Prisma.$PostImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageCountArgs} args - Arguments to filter PostImages to count.
     * @example
     * // Count the number of PostImages
     * const count = await prisma.postImage.count({
     *   where: {
     *     // ... the filter for the PostImages we want to count
     *   }
     * })
    **/
    count<T extends PostImageCountArgs>(
      args?: Subset<T, PostImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostImageAggregateArgs>(args: Subset<T, PostImageAggregateArgs>): Prisma.PrismaPromise<GetPostImageAggregateType<T>>

    /**
     * Group by PostImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostImageGroupByArgs['orderBy'] }
        : { orderBy?: PostImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostImage model
   */
  readonly fields: PostImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostImage model
   */
  interface PostImageFieldRefs {
    readonly id: FieldRef<"PostImage", 'Int'>
    readonly post_id: FieldRef<"PostImage", 'Int'>
    readonly image_url: FieldRef<"PostImage", 'String'>
    readonly created_at: FieldRef<"PostImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostImage findUnique
   */
  export type PostImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage findUniqueOrThrow
   */
  export type PostImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage findFirst
   */
  export type PostImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostImages.
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostImages.
     */
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * PostImage findFirstOrThrow
   */
  export type PostImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImage to fetch.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostImages.
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostImages.
     */
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * PostImage findMany
   */
  export type PostImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter, which PostImages to fetch.
     */
    where?: PostImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostImages to fetch.
     */
    orderBy?: PostImageOrderByWithRelationInput | PostImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostImages.
     */
    cursor?: PostImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostImages.
     */
    skip?: number
    distinct?: PostImageScalarFieldEnum | PostImageScalarFieldEnum[]
  }

  /**
   * PostImage create
   */
  export type PostImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * The data needed to create a PostImage.
     */
    data: XOR<PostImageCreateInput, PostImageUncheckedCreateInput>
  }

  /**
   * PostImage createMany
   */
  export type PostImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostImages.
     */
    data: PostImageCreateManyInput | PostImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostImage createManyAndReturn
   */
  export type PostImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * The data used to create many PostImages.
     */
    data: PostImageCreateManyInput | PostImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostImage update
   */
  export type PostImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * The data needed to update a PostImage.
     */
    data: XOR<PostImageUpdateInput, PostImageUncheckedUpdateInput>
    /**
     * Choose, which PostImage to update.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage updateMany
   */
  export type PostImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostImages.
     */
    data: XOR<PostImageUpdateManyMutationInput, PostImageUncheckedUpdateManyInput>
    /**
     * Filter which PostImages to update
     */
    where?: PostImageWhereInput
    /**
     * Limit how many PostImages to update.
     */
    limit?: number
  }

  /**
   * PostImage updateManyAndReturn
   */
  export type PostImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * The data used to update PostImages.
     */
    data: XOR<PostImageUpdateManyMutationInput, PostImageUncheckedUpdateManyInput>
    /**
     * Filter which PostImages to update
     */
    where?: PostImageWhereInput
    /**
     * Limit how many PostImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostImage upsert
   */
  export type PostImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * The filter to search for the PostImage to update in case it exists.
     */
    where: PostImageWhereUniqueInput
    /**
     * In case the PostImage found by the `where` argument doesn't exist, create a new PostImage with this data.
     */
    create: XOR<PostImageCreateInput, PostImageUncheckedCreateInput>
    /**
     * In case the PostImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostImageUpdateInput, PostImageUncheckedUpdateInput>
  }

  /**
   * PostImage delete
   */
  export type PostImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
    /**
     * Filter which PostImage to delete.
     */
    where: PostImageWhereUniqueInput
  }

  /**
   * PostImage deleteMany
   */
  export type PostImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostImages to delete
     */
    where?: PostImageWhereInput
    /**
     * Limit how many PostImages to delete.
     */
    limit?: number
  }

  /**
   * PostImage without action
   */
  export type PostImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostImage
     */
    select?: PostImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostImage
     */
    omit?: PostImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostImageInclude<ExtArgs> | null
  }


  /**
   * Model BlockedUser
   */

  export type AggregateBlockedUser = {
    _count: BlockedUserCountAggregateOutputType | null
    _avg: BlockedUserAvgAggregateOutputType | null
    _sum: BlockedUserSumAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  export type BlockedUserAvgAggregateOutputType = {
    id: number | null
    blockerId: number | null
    blockedId: number | null
  }

  export type BlockedUserSumAggregateOutputType = {
    id: number | null
    blockerId: number | null
    blockedId: number | null
  }

  export type BlockedUserMinAggregateOutputType = {
    id: number | null
    blockerId: number | null
    blockedId: number | null
    createdAt: Date | null
  }

  export type BlockedUserMaxAggregateOutputType = {
    id: number | null
    blockerId: number | null
    blockedId: number | null
    createdAt: Date | null
  }

  export type BlockedUserCountAggregateOutputType = {
    id: number
    blockerId: number
    blockedId: number
    createdAt: number
    _all: number
  }


  export type BlockedUserAvgAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
  }

  export type BlockedUserSumAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
  }

  export type BlockedUserMinAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
  }

  export type BlockedUserMaxAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
  }

  export type BlockedUserCountAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
    _all?: true
  }

  export type BlockedUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUser to aggregate.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedUsers
    **/
    _count?: true | BlockedUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockedUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockedUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedUserMaxAggregateInputType
  }

  export type GetBlockedUserAggregateType<T extends BlockedUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedUser[P]>
      : GetScalarType<T[P], AggregateBlockedUser[P]>
  }




  export type BlockedUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithAggregationInput | BlockedUserOrderByWithAggregationInput[]
    by: BlockedUserScalarFieldEnum[] | BlockedUserScalarFieldEnum
    having?: BlockedUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedUserCountAggregateInputType | true
    _avg?: BlockedUserAvgAggregateInputType
    _sum?: BlockedUserSumAggregateInputType
    _min?: BlockedUserMinAggregateInputType
    _max?: BlockedUserMaxAggregateInputType
  }

  export type BlockedUserGroupByOutputType = {
    id: number
    blockerId: number
    blockedId: number
    createdAt: Date
    _count: BlockedUserCountAggregateOutputType | null
    _avg: BlockedUserAvgAggregateOutputType | null
    _sum: BlockedUserSumAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  type GetBlockedUserGroupByPayload<T extends BlockedUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockedUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
        }
      >
    >


  export type BlockedUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocker?: boolean | MemberDefaultArgs<ExtArgs>
    blocked?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocker?: boolean | MemberDefaultArgs<ExtArgs>
    blocked?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocker?: boolean | MemberDefaultArgs<ExtArgs>
    blocked?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectScalar = {
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
  }

  export type BlockedUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "blockerId" | "blockedId" | "createdAt", ExtArgs["result"]["blockedUser"]>
  export type BlockedUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | MemberDefaultArgs<ExtArgs>
    blocked?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type BlockedUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | MemberDefaultArgs<ExtArgs>
    blocked?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type BlockedUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | MemberDefaultArgs<ExtArgs>
    blocked?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $BlockedUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockedUser"
    objects: {
      blocker: Prisma.$MemberPayload<ExtArgs>
      blocked: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      blockerId: number
      blockedId: number
      createdAt: Date
    }, ExtArgs["result"]["blockedUser"]>
    composites: {}
  }

  type BlockedUserGetPayload<S extends boolean | null | undefined | BlockedUserDefaultArgs> = $Result.GetResult<Prisma.$BlockedUserPayload, S>

  type BlockedUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockedUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockedUserCountAggregateInputType | true
    }

  export interface BlockedUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockedUser'], meta: { name: 'BlockedUser' } }
    /**
     * Find zero or one BlockedUser that matches the filter.
     * @param {BlockedUserFindUniqueArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockedUserFindUniqueArgs>(args: SelectSubset<T, BlockedUserFindUniqueArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlockedUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockedUserFindUniqueOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockedUserFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockedUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockedUserFindFirstArgs>(args?: SelectSubset<T, BlockedUserFindFirstArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockedUserFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockedUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlockedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany()
     * 
     * // Get first 10 BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockedUserFindManyArgs>(args?: SelectSubset<T, BlockedUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlockedUser.
     * @param {BlockedUserCreateArgs} args - Arguments to create a BlockedUser.
     * @example
     * // Create one BlockedUser
     * const BlockedUser = await prisma.blockedUser.create({
     *   data: {
     *     // ... data to create a BlockedUser
     *   }
     * })
     * 
     */
    create<T extends BlockedUserCreateArgs>(args: SelectSubset<T, BlockedUserCreateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlockedUsers.
     * @param {BlockedUserCreateManyArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockedUserCreateManyArgs>(args?: SelectSubset<T, BlockedUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockedUsers and returns the data saved in the database.
     * @param {BlockedUserCreateManyAndReturnArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockedUsers and only return the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockedUserCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockedUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlockedUser.
     * @param {BlockedUserDeleteArgs} args - Arguments to delete one BlockedUser.
     * @example
     * // Delete one BlockedUser
     * const BlockedUser = await prisma.blockedUser.delete({
     *   where: {
     *     // ... filter to delete one BlockedUser
     *   }
     * })
     * 
     */
    delete<T extends BlockedUserDeleteArgs>(args: SelectSubset<T, BlockedUserDeleteArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlockedUser.
     * @param {BlockedUserUpdateArgs} args - Arguments to update one BlockedUser.
     * @example
     * // Update one BlockedUser
     * const blockedUser = await prisma.blockedUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockedUserUpdateArgs>(args: SelectSubset<T, BlockedUserUpdateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlockedUsers.
     * @param {BlockedUserDeleteManyArgs} args - Arguments to filter BlockedUsers to delete.
     * @example
     * // Delete a few BlockedUsers
     * const { count } = await prisma.blockedUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockedUserDeleteManyArgs>(args?: SelectSubset<T, BlockedUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedUsers
     * const blockedUser = await prisma.blockedUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockedUserUpdateManyArgs>(args: SelectSubset<T, BlockedUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUsers and returns the data updated in the database.
     * @param {BlockedUserUpdateManyAndReturnArgs} args - Arguments to update many BlockedUsers.
     * @example
     * // Update many BlockedUsers
     * const blockedUser = await prisma.blockedUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlockedUsers and only return the `id`
     * const blockedUserWithIdOnly = await prisma.blockedUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockedUserUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockedUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlockedUser.
     * @param {BlockedUserUpsertArgs} args - Arguments to update or create a BlockedUser.
     * @example
     * // Update or create a BlockedUser
     * const blockedUser = await prisma.blockedUser.upsert({
     *   create: {
     *     // ... data to create a BlockedUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedUser we want to update
     *   }
     * })
     */
    upsert<T extends BlockedUserUpsertArgs>(args: SelectSubset<T, BlockedUserUpsertArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserCountArgs} args - Arguments to filter BlockedUsers to count.
     * @example
     * // Count the number of BlockedUsers
     * const count = await prisma.blockedUser.count({
     *   where: {
     *     // ... the filter for the BlockedUsers we want to count
     *   }
     * })
    **/
    count<T extends BlockedUserCountArgs>(
      args?: Subset<T, BlockedUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedUserAggregateArgs>(args: Subset<T, BlockedUserAggregateArgs>): Prisma.PrismaPromise<GetBlockedUserAggregateType<T>>

    /**
     * Group by BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedUserGroupByArgs['orderBy'] }
        : { orderBy?: BlockedUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockedUser model
   */
  readonly fields: BlockedUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockedUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocker<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blocked<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockedUser model
   */
  interface BlockedUserFieldRefs {
    readonly id: FieldRef<"BlockedUser", 'Int'>
    readonly blockerId: FieldRef<"BlockedUser", 'Int'>
    readonly blockedId: FieldRef<"BlockedUser", 'Int'>
    readonly createdAt: FieldRef<"BlockedUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockedUser findUnique
   */
  export type BlockedUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findUniqueOrThrow
   */
  export type BlockedUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findFirst
   */
  export type BlockedUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findFirstOrThrow
   */
  export type BlockedUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findMany
   */
  export type BlockedUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUsers to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser create
   */
  export type BlockedUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockedUser.
     */
    data: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
  }

  /**
   * BlockedUser createMany
   */
  export type BlockedUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedUser createManyAndReturn
   */
  export type BlockedUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedUser update
   */
  export type BlockedUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockedUser.
     */
    data: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
    /**
     * Choose, which BlockedUser to update.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser updateMany
   */
  export type BlockedUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockedUsers.
     */
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUsers to update
     */
    where?: BlockedUserWhereInput
    /**
     * Limit how many BlockedUsers to update.
     */
    limit?: number
  }

  /**
   * BlockedUser updateManyAndReturn
   */
  export type BlockedUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * The data used to update BlockedUsers.
     */
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUsers to update
     */
    where?: BlockedUserWhereInput
    /**
     * Limit how many BlockedUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedUser upsert
   */
  export type BlockedUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockedUser to update in case it exists.
     */
    where: BlockedUserWhereUniqueInput
    /**
     * In case the BlockedUser found by the `where` argument doesn't exist, create a new BlockedUser with this data.
     */
    create: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
    /**
     * In case the BlockedUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
  }

  /**
   * BlockedUser delete
   */
  export type BlockedUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter which BlockedUser to delete.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser deleteMany
   */
  export type BlockedUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUsers to delete
     */
    where?: BlockedUserWhereInput
    /**
     * Limit how many BlockedUsers to delete.
     */
    limit?: number
  }

  /**
   * BlockedUser without action
   */
  export type BlockedUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
  }


  /**
   * Model UserReport
   */

  export type AggregateUserReport = {
    _count: UserReportCountAggregateOutputType | null
    _avg: UserReportAvgAggregateOutputType | null
    _sum: UserReportSumAggregateOutputType | null
    _min: UserReportMinAggregateOutputType | null
    _max: UserReportMaxAggregateOutputType | null
  }

  export type UserReportAvgAggregateOutputType = {
    id: number | null
    reporterId: number | null
    reportedId: number | null
  }

  export type UserReportSumAggregateOutputType = {
    id: number | null
    reporterId: number | null
    reportedId: number | null
  }

  export type UserReportMinAggregateOutputType = {
    id: number | null
    reporterId: number | null
    reportedId: number | null
    reason: string | null
    createdAt: Date | null
    type: string | null
  }

  export type UserReportMaxAggregateOutputType = {
    id: number | null
    reporterId: number | null
    reportedId: number | null
    reason: string | null
    createdAt: Date | null
    type: string | null
  }

  export type UserReportCountAggregateOutputType = {
    id: number
    reporterId: number
    reportedId: number
    reason: number
    createdAt: number
    type: number
    _all: number
  }


  export type UserReportAvgAggregateInputType = {
    id?: true
    reporterId?: true
    reportedId?: true
  }

  export type UserReportSumAggregateInputType = {
    id?: true
    reporterId?: true
    reportedId?: true
  }

  export type UserReportMinAggregateInputType = {
    id?: true
    reporterId?: true
    reportedId?: true
    reason?: true
    createdAt?: true
    type?: true
  }

  export type UserReportMaxAggregateInputType = {
    id?: true
    reporterId?: true
    reportedId?: true
    reason?: true
    createdAt?: true
    type?: true
  }

  export type UserReportCountAggregateInputType = {
    id?: true
    reporterId?: true
    reportedId?: true
    reason?: true
    createdAt?: true
    type?: true
    _all?: true
  }

  export type UserReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserReport to aggregate.
     */
    where?: UserReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReports to fetch.
     */
    orderBy?: UserReportOrderByWithRelationInput | UserReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserReports
    **/
    _count?: true | UserReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserReportMaxAggregateInputType
  }

  export type GetUserReportAggregateType<T extends UserReportAggregateArgs> = {
        [P in keyof T & keyof AggregateUserReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserReport[P]>
      : GetScalarType<T[P], AggregateUserReport[P]>
  }




  export type UserReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserReportWhereInput
    orderBy?: UserReportOrderByWithAggregationInput | UserReportOrderByWithAggregationInput[]
    by: UserReportScalarFieldEnum[] | UserReportScalarFieldEnum
    having?: UserReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserReportCountAggregateInputType | true
    _avg?: UserReportAvgAggregateInputType
    _sum?: UserReportSumAggregateInputType
    _min?: UserReportMinAggregateInputType
    _max?: UserReportMaxAggregateInputType
  }

  export type UserReportGroupByOutputType = {
    id: number
    reporterId: number
    reportedId: number
    reason: string
    createdAt: Date
    type: string
    _count: UserReportCountAggregateOutputType | null
    _avg: UserReportAvgAggregateOutputType | null
    _sum: UserReportSumAggregateOutputType | null
    _min: UserReportMinAggregateOutputType | null
    _max: UserReportMaxAggregateOutputType | null
  }

  type GetUserReportGroupByPayload<T extends UserReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserReportGroupByOutputType[P]>
            : GetScalarType<T[P], UserReportGroupByOutputType[P]>
        }
      >
    >


  export type UserReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedId?: boolean
    reason?: boolean
    createdAt?: boolean
    type?: boolean
    reporter?: boolean | MemberDefaultArgs<ExtArgs>
    reported?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userReport"]>

  export type UserReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedId?: boolean
    reason?: boolean
    createdAt?: boolean
    type?: boolean
    reporter?: boolean | MemberDefaultArgs<ExtArgs>
    reported?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userReport"]>

  export type UserReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reporterId?: boolean
    reportedId?: boolean
    reason?: boolean
    createdAt?: boolean
    type?: boolean
    reporter?: boolean | MemberDefaultArgs<ExtArgs>
    reported?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userReport"]>

  export type UserReportSelectScalar = {
    id?: boolean
    reporterId?: boolean
    reportedId?: boolean
    reason?: boolean
    createdAt?: boolean
    type?: boolean
  }

  export type UserReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reporterId" | "reportedId" | "reason" | "createdAt" | "type", ExtArgs["result"]["userReport"]>
  export type UserReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | MemberDefaultArgs<ExtArgs>
    reported?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type UserReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | MemberDefaultArgs<ExtArgs>
    reported?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type UserReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reporter?: boolean | MemberDefaultArgs<ExtArgs>
    reported?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $UserReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserReport"
    objects: {
      reporter: Prisma.$MemberPayload<ExtArgs>
      reported: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reporterId: number
      reportedId: number
      reason: string
      createdAt: Date
      type: string
    }, ExtArgs["result"]["userReport"]>
    composites: {}
  }

  type UserReportGetPayload<S extends boolean | null | undefined | UserReportDefaultArgs> = $Result.GetResult<Prisma.$UserReportPayload, S>

  type UserReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserReportCountAggregateInputType | true
    }

  export interface UserReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserReport'], meta: { name: 'UserReport' } }
    /**
     * Find zero or one UserReport that matches the filter.
     * @param {UserReportFindUniqueArgs} args - Arguments to find a UserReport
     * @example
     * // Get one UserReport
     * const userReport = await prisma.userReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserReportFindUniqueArgs>(args: SelectSubset<T, UserReportFindUniqueArgs<ExtArgs>>): Prisma__UserReportClient<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserReportFindUniqueOrThrowArgs} args - Arguments to find a UserReport
     * @example
     * // Get one UserReport
     * const userReport = await prisma.userReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserReportFindUniqueOrThrowArgs>(args: SelectSubset<T, UserReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserReportClient<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReportFindFirstArgs} args - Arguments to find a UserReport
     * @example
     * // Get one UserReport
     * const userReport = await prisma.userReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserReportFindFirstArgs>(args?: SelectSubset<T, UserReportFindFirstArgs<ExtArgs>>): Prisma__UserReportClient<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReportFindFirstOrThrowArgs} args - Arguments to find a UserReport
     * @example
     * // Get one UserReport
     * const userReport = await prisma.userReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserReportFindFirstOrThrowArgs>(args?: SelectSubset<T, UserReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserReportClient<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserReports
     * const userReports = await prisma.userReport.findMany()
     * 
     * // Get first 10 UserReports
     * const userReports = await prisma.userReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userReportWithIdOnly = await prisma.userReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserReportFindManyArgs>(args?: SelectSubset<T, UserReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserReport.
     * @param {UserReportCreateArgs} args - Arguments to create a UserReport.
     * @example
     * // Create one UserReport
     * const UserReport = await prisma.userReport.create({
     *   data: {
     *     // ... data to create a UserReport
     *   }
     * })
     * 
     */
    create<T extends UserReportCreateArgs>(args: SelectSubset<T, UserReportCreateArgs<ExtArgs>>): Prisma__UserReportClient<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserReports.
     * @param {UserReportCreateManyArgs} args - Arguments to create many UserReports.
     * @example
     * // Create many UserReports
     * const userReport = await prisma.userReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserReportCreateManyArgs>(args?: SelectSubset<T, UserReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserReports and returns the data saved in the database.
     * @param {UserReportCreateManyAndReturnArgs} args - Arguments to create many UserReports.
     * @example
     * // Create many UserReports
     * const userReport = await prisma.userReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserReports and only return the `id`
     * const userReportWithIdOnly = await prisma.userReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserReportCreateManyAndReturnArgs>(args?: SelectSubset<T, UserReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserReport.
     * @param {UserReportDeleteArgs} args - Arguments to delete one UserReport.
     * @example
     * // Delete one UserReport
     * const UserReport = await prisma.userReport.delete({
     *   where: {
     *     // ... filter to delete one UserReport
     *   }
     * })
     * 
     */
    delete<T extends UserReportDeleteArgs>(args: SelectSubset<T, UserReportDeleteArgs<ExtArgs>>): Prisma__UserReportClient<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserReport.
     * @param {UserReportUpdateArgs} args - Arguments to update one UserReport.
     * @example
     * // Update one UserReport
     * const userReport = await prisma.userReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserReportUpdateArgs>(args: SelectSubset<T, UserReportUpdateArgs<ExtArgs>>): Prisma__UserReportClient<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserReports.
     * @param {UserReportDeleteManyArgs} args - Arguments to filter UserReports to delete.
     * @example
     * // Delete a few UserReports
     * const { count } = await prisma.userReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserReportDeleteManyArgs>(args?: SelectSubset<T, UserReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserReports
     * const userReport = await prisma.userReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserReportUpdateManyArgs>(args: SelectSubset<T, UserReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserReports and returns the data updated in the database.
     * @param {UserReportUpdateManyAndReturnArgs} args - Arguments to update many UserReports.
     * @example
     * // Update many UserReports
     * const userReport = await prisma.userReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserReports and only return the `id`
     * const userReportWithIdOnly = await prisma.userReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserReportUpdateManyAndReturnArgs>(args: SelectSubset<T, UserReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserReport.
     * @param {UserReportUpsertArgs} args - Arguments to update or create a UserReport.
     * @example
     * // Update or create a UserReport
     * const userReport = await prisma.userReport.upsert({
     *   create: {
     *     // ... data to create a UserReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserReport we want to update
     *   }
     * })
     */
    upsert<T extends UserReportUpsertArgs>(args: SelectSubset<T, UserReportUpsertArgs<ExtArgs>>): Prisma__UserReportClient<$Result.GetResult<Prisma.$UserReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReportCountArgs} args - Arguments to filter UserReports to count.
     * @example
     * // Count the number of UserReports
     * const count = await prisma.userReport.count({
     *   where: {
     *     // ... the filter for the UserReports we want to count
     *   }
     * })
    **/
    count<T extends UserReportCountArgs>(
      args?: Subset<T, UserReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserReportAggregateArgs>(args: Subset<T, UserReportAggregateArgs>): Prisma.PrismaPromise<GetUserReportAggregateType<T>>

    /**
     * Group by UserReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserReportGroupByArgs['orderBy'] }
        : { orderBy?: UserReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserReport model
   */
  readonly fields: UserReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reporter<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reported<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserReport model
   */
  interface UserReportFieldRefs {
    readonly id: FieldRef<"UserReport", 'Int'>
    readonly reporterId: FieldRef<"UserReport", 'Int'>
    readonly reportedId: FieldRef<"UserReport", 'Int'>
    readonly reason: FieldRef<"UserReport", 'String'>
    readonly createdAt: FieldRef<"UserReport", 'DateTime'>
    readonly type: FieldRef<"UserReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserReport findUnique
   */
  export type UserReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    /**
     * Filter, which UserReport to fetch.
     */
    where: UserReportWhereUniqueInput
  }

  /**
   * UserReport findUniqueOrThrow
   */
  export type UserReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    /**
     * Filter, which UserReport to fetch.
     */
    where: UserReportWhereUniqueInput
  }

  /**
   * UserReport findFirst
   */
  export type UserReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    /**
     * Filter, which UserReport to fetch.
     */
    where?: UserReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReports to fetch.
     */
    orderBy?: UserReportOrderByWithRelationInput | UserReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserReports.
     */
    cursor?: UserReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserReports.
     */
    distinct?: UserReportScalarFieldEnum | UserReportScalarFieldEnum[]
  }

  /**
   * UserReport findFirstOrThrow
   */
  export type UserReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    /**
     * Filter, which UserReport to fetch.
     */
    where?: UserReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReports to fetch.
     */
    orderBy?: UserReportOrderByWithRelationInput | UserReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserReports.
     */
    cursor?: UserReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserReports.
     */
    distinct?: UserReportScalarFieldEnum | UserReportScalarFieldEnum[]
  }

  /**
   * UserReport findMany
   */
  export type UserReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    /**
     * Filter, which UserReports to fetch.
     */
    where?: UserReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserReports to fetch.
     */
    orderBy?: UserReportOrderByWithRelationInput | UserReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserReports.
     */
    cursor?: UserReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserReports.
     */
    skip?: number
    distinct?: UserReportScalarFieldEnum | UserReportScalarFieldEnum[]
  }

  /**
   * UserReport create
   */
  export type UserReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    /**
     * The data needed to create a UserReport.
     */
    data: XOR<UserReportCreateInput, UserReportUncheckedCreateInput>
  }

  /**
   * UserReport createMany
   */
  export type UserReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserReports.
     */
    data: UserReportCreateManyInput | UserReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserReport createManyAndReturn
   */
  export type UserReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * The data used to create many UserReports.
     */
    data: UserReportCreateManyInput | UserReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserReport update
   */
  export type UserReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    /**
     * The data needed to update a UserReport.
     */
    data: XOR<UserReportUpdateInput, UserReportUncheckedUpdateInput>
    /**
     * Choose, which UserReport to update.
     */
    where: UserReportWhereUniqueInput
  }

  /**
   * UserReport updateMany
   */
  export type UserReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserReports.
     */
    data: XOR<UserReportUpdateManyMutationInput, UserReportUncheckedUpdateManyInput>
    /**
     * Filter which UserReports to update
     */
    where?: UserReportWhereInput
    /**
     * Limit how many UserReports to update.
     */
    limit?: number
  }

  /**
   * UserReport updateManyAndReturn
   */
  export type UserReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * The data used to update UserReports.
     */
    data: XOR<UserReportUpdateManyMutationInput, UserReportUncheckedUpdateManyInput>
    /**
     * Filter which UserReports to update
     */
    where?: UserReportWhereInput
    /**
     * Limit how many UserReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserReport upsert
   */
  export type UserReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    /**
     * The filter to search for the UserReport to update in case it exists.
     */
    where: UserReportWhereUniqueInput
    /**
     * In case the UserReport found by the `where` argument doesn't exist, create a new UserReport with this data.
     */
    create: XOR<UserReportCreateInput, UserReportUncheckedCreateInput>
    /**
     * In case the UserReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserReportUpdateInput, UserReportUncheckedUpdateInput>
  }

  /**
   * UserReport delete
   */
  export type UserReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
    /**
     * Filter which UserReport to delete.
     */
    where: UserReportWhereUniqueInput
  }

  /**
   * UserReport deleteMany
   */
  export type UserReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserReports to delete
     */
    where?: UserReportWhereInput
    /**
     * Limit how many UserReports to delete.
     */
    limit?: number
  }

  /**
   * UserReport without action
   */
  export type UserReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserReport
     */
    select?: UserReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserReport
     */
    omit?: UserReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserReportInclude<ExtArgs> | null
  }


  /**
   * Model UserMessage
   */

  export type AggregateUserMessage = {
    _count: UserMessageCountAggregateOutputType | null
    _avg: UserMessageAvgAggregateOutputType | null
    _sum: UserMessageSumAggregateOutputType | null
    _min: UserMessageMinAggregateOutputType | null
    _max: UserMessageMaxAggregateOutputType | null
  }

  export type UserMessageAvgAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
  }

  export type UserMessageSumAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
  }

  export type UserMessageMinAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    is_deleted_by_sender: boolean | null
    is_deleted_by_receiver: boolean | null
  }

  export type UserMessageMaxAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
    content: string | null
    isRead: boolean | null
    createdAt: Date | null
    is_deleted_by_sender: boolean | null
    is_deleted_by_receiver: boolean | null
  }

  export type UserMessageCountAggregateOutputType = {
    id: number
    sender_id: number
    receiver_id: number
    content: number
    isRead: number
    createdAt: number
    is_deleted_by_sender: number
    is_deleted_by_receiver: number
    _all: number
  }


  export type UserMessageAvgAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
  }

  export type UserMessageSumAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
  }

  export type UserMessageMinAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    content?: true
    isRead?: true
    createdAt?: true
    is_deleted_by_sender?: true
    is_deleted_by_receiver?: true
  }

  export type UserMessageMaxAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    content?: true
    isRead?: true
    createdAt?: true
    is_deleted_by_sender?: true
    is_deleted_by_receiver?: true
  }

  export type UserMessageCountAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    content?: true
    isRead?: true
    createdAt?: true
    is_deleted_by_sender?: true
    is_deleted_by_receiver?: true
    _all?: true
  }

  export type UserMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMessage to aggregate.
     */
    where?: UserMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMessages to fetch.
     */
    orderBy?: UserMessageOrderByWithRelationInput | UserMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserMessages
    **/
    _count?: true | UserMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMessageMaxAggregateInputType
  }

  export type GetUserMessageAggregateType<T extends UserMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateUserMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserMessage[P]>
      : GetScalarType<T[P], AggregateUserMessage[P]>
  }




  export type UserMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserMessageWhereInput
    orderBy?: UserMessageOrderByWithAggregationInput | UserMessageOrderByWithAggregationInput[]
    by: UserMessageScalarFieldEnum[] | UserMessageScalarFieldEnum
    having?: UserMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserMessageCountAggregateInputType | true
    _avg?: UserMessageAvgAggregateInputType
    _sum?: UserMessageSumAggregateInputType
    _min?: UserMessageMinAggregateInputType
    _max?: UserMessageMaxAggregateInputType
  }

  export type UserMessageGroupByOutputType = {
    id: number
    sender_id: number
    receiver_id: number
    content: string
    isRead: boolean
    createdAt: Date
    is_deleted_by_sender: boolean
    is_deleted_by_receiver: boolean
    _count: UserMessageCountAggregateOutputType | null
    _avg: UserMessageAvgAggregateOutputType | null
    _sum: UserMessageSumAggregateOutputType | null
    _min: UserMessageMinAggregateOutputType | null
    _max: UserMessageMaxAggregateOutputType | null
  }

  type GetUserMessageGroupByPayload<T extends UserMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserMessageGroupByOutputType[P]>
            : GetScalarType<T[P], UserMessageGroupByOutputType[P]>
        }
      >
    >


  export type UserMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMessage"]>

  export type UserMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMessage"]>

  export type UserMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userMessage"]>

  export type UserMessageSelectScalar = {
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    content?: boolean
    isRead?: boolean
    createdAt?: boolean
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
  }

  export type UserMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sender_id" | "receiver_id" | "content" | "isRead" | "createdAt" | "is_deleted_by_sender" | "is_deleted_by_receiver", ExtArgs["result"]["userMessage"]>
  export type UserMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type UserMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
  }
  export type UserMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
  }

  export type $UserMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserMessage"
    objects: {
      sender: Prisma.$MemberPayload<ExtArgs>
      receiver: Prisma.$MemberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sender_id: number
      receiver_id: number
      content: string
      isRead: boolean
      createdAt: Date
      is_deleted_by_sender: boolean
      is_deleted_by_receiver: boolean
    }, ExtArgs["result"]["userMessage"]>
    composites: {}
  }

  type UserMessageGetPayload<S extends boolean | null | undefined | UserMessageDefaultArgs> = $Result.GetResult<Prisma.$UserMessagePayload, S>

  type UserMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserMessageCountAggregateInputType | true
    }

  export interface UserMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserMessage'], meta: { name: 'UserMessage' } }
    /**
     * Find zero or one UserMessage that matches the filter.
     * @param {UserMessageFindUniqueArgs} args - Arguments to find a UserMessage
     * @example
     * // Get one UserMessage
     * const userMessage = await prisma.userMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserMessageFindUniqueArgs>(args: SelectSubset<T, UserMessageFindUniqueArgs<ExtArgs>>): Prisma__UserMessageClient<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserMessageFindUniqueOrThrowArgs} args - Arguments to find a UserMessage
     * @example
     * // Get one UserMessage
     * const userMessage = await prisma.userMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, UserMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserMessageClient<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessageFindFirstArgs} args - Arguments to find a UserMessage
     * @example
     * // Get one UserMessage
     * const userMessage = await prisma.userMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserMessageFindFirstArgs>(args?: SelectSubset<T, UserMessageFindFirstArgs<ExtArgs>>): Prisma__UserMessageClient<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessageFindFirstOrThrowArgs} args - Arguments to find a UserMessage
     * @example
     * // Get one UserMessage
     * const userMessage = await prisma.userMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, UserMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserMessageClient<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserMessages
     * const userMessages = await prisma.userMessage.findMany()
     * 
     * // Get first 10 UserMessages
     * const userMessages = await prisma.userMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userMessageWithIdOnly = await prisma.userMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserMessageFindManyArgs>(args?: SelectSubset<T, UserMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserMessage.
     * @param {UserMessageCreateArgs} args - Arguments to create a UserMessage.
     * @example
     * // Create one UserMessage
     * const UserMessage = await prisma.userMessage.create({
     *   data: {
     *     // ... data to create a UserMessage
     *   }
     * })
     * 
     */
    create<T extends UserMessageCreateArgs>(args: SelectSubset<T, UserMessageCreateArgs<ExtArgs>>): Prisma__UserMessageClient<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserMessages.
     * @param {UserMessageCreateManyArgs} args - Arguments to create many UserMessages.
     * @example
     * // Create many UserMessages
     * const userMessage = await prisma.userMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserMessageCreateManyArgs>(args?: SelectSubset<T, UserMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserMessages and returns the data saved in the database.
     * @param {UserMessageCreateManyAndReturnArgs} args - Arguments to create many UserMessages.
     * @example
     * // Create many UserMessages
     * const userMessage = await prisma.userMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserMessages and only return the `id`
     * const userMessageWithIdOnly = await prisma.userMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, UserMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserMessage.
     * @param {UserMessageDeleteArgs} args - Arguments to delete one UserMessage.
     * @example
     * // Delete one UserMessage
     * const UserMessage = await prisma.userMessage.delete({
     *   where: {
     *     // ... filter to delete one UserMessage
     *   }
     * })
     * 
     */
    delete<T extends UserMessageDeleteArgs>(args: SelectSubset<T, UserMessageDeleteArgs<ExtArgs>>): Prisma__UserMessageClient<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserMessage.
     * @param {UserMessageUpdateArgs} args - Arguments to update one UserMessage.
     * @example
     * // Update one UserMessage
     * const userMessage = await prisma.userMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserMessageUpdateArgs>(args: SelectSubset<T, UserMessageUpdateArgs<ExtArgs>>): Prisma__UserMessageClient<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserMessages.
     * @param {UserMessageDeleteManyArgs} args - Arguments to filter UserMessages to delete.
     * @example
     * // Delete a few UserMessages
     * const { count } = await prisma.userMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserMessageDeleteManyArgs>(args?: SelectSubset<T, UserMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserMessages
     * const userMessage = await prisma.userMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserMessageUpdateManyArgs>(args: SelectSubset<T, UserMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserMessages and returns the data updated in the database.
     * @param {UserMessageUpdateManyAndReturnArgs} args - Arguments to update many UserMessages.
     * @example
     * // Update many UserMessages
     * const userMessage = await prisma.userMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserMessages and only return the `id`
     * const userMessageWithIdOnly = await prisma.userMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, UserMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserMessage.
     * @param {UserMessageUpsertArgs} args - Arguments to update or create a UserMessage.
     * @example
     * // Update or create a UserMessage
     * const userMessage = await prisma.userMessage.upsert({
     *   create: {
     *     // ... data to create a UserMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserMessage we want to update
     *   }
     * })
     */
    upsert<T extends UserMessageUpsertArgs>(args: SelectSubset<T, UserMessageUpsertArgs<ExtArgs>>): Prisma__UserMessageClient<$Result.GetResult<Prisma.$UserMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessageCountArgs} args - Arguments to filter UserMessages to count.
     * @example
     * // Count the number of UserMessages
     * const count = await prisma.userMessage.count({
     *   where: {
     *     // ... the filter for the UserMessages we want to count
     *   }
     * })
    **/
    count<T extends UserMessageCountArgs>(
      args?: Subset<T, UserMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserMessageAggregateArgs>(args: Subset<T, UserMessageAggregateArgs>): Prisma.PrismaPromise<GetUserMessageAggregateType<T>>

    /**
     * Group by UserMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserMessageGroupByArgs['orderBy'] }
        : { orderBy?: UserMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserMessage model
   */
  readonly fields: UserMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserMessage model
   */
  interface UserMessageFieldRefs {
    readonly id: FieldRef<"UserMessage", 'Int'>
    readonly sender_id: FieldRef<"UserMessage", 'Int'>
    readonly receiver_id: FieldRef<"UserMessage", 'Int'>
    readonly content: FieldRef<"UserMessage", 'String'>
    readonly isRead: FieldRef<"UserMessage", 'Boolean'>
    readonly createdAt: FieldRef<"UserMessage", 'DateTime'>
    readonly is_deleted_by_sender: FieldRef<"UserMessage", 'Boolean'>
    readonly is_deleted_by_receiver: FieldRef<"UserMessage", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserMessage findUnique
   */
  export type UserMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    /**
     * Filter, which UserMessage to fetch.
     */
    where: UserMessageWhereUniqueInput
  }

  /**
   * UserMessage findUniqueOrThrow
   */
  export type UserMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    /**
     * Filter, which UserMessage to fetch.
     */
    where: UserMessageWhereUniqueInput
  }

  /**
   * UserMessage findFirst
   */
  export type UserMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    /**
     * Filter, which UserMessage to fetch.
     */
    where?: UserMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMessages to fetch.
     */
    orderBy?: UserMessageOrderByWithRelationInput | UserMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMessages.
     */
    cursor?: UserMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMessages.
     */
    distinct?: UserMessageScalarFieldEnum | UserMessageScalarFieldEnum[]
  }

  /**
   * UserMessage findFirstOrThrow
   */
  export type UserMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    /**
     * Filter, which UserMessage to fetch.
     */
    where?: UserMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMessages to fetch.
     */
    orderBy?: UserMessageOrderByWithRelationInput | UserMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserMessages.
     */
    cursor?: UserMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserMessages.
     */
    distinct?: UserMessageScalarFieldEnum | UserMessageScalarFieldEnum[]
  }

  /**
   * UserMessage findMany
   */
  export type UserMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    /**
     * Filter, which UserMessages to fetch.
     */
    where?: UserMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserMessages to fetch.
     */
    orderBy?: UserMessageOrderByWithRelationInput | UserMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserMessages.
     */
    cursor?: UserMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserMessages.
     */
    skip?: number
    distinct?: UserMessageScalarFieldEnum | UserMessageScalarFieldEnum[]
  }

  /**
   * UserMessage create
   */
  export type UserMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a UserMessage.
     */
    data: XOR<UserMessageCreateInput, UserMessageUncheckedCreateInput>
  }

  /**
   * UserMessage createMany
   */
  export type UserMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserMessages.
     */
    data: UserMessageCreateManyInput | UserMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserMessage createManyAndReturn
   */
  export type UserMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * The data used to create many UserMessages.
     */
    data: UserMessageCreateManyInput | UserMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMessage update
   */
  export type UserMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a UserMessage.
     */
    data: XOR<UserMessageUpdateInput, UserMessageUncheckedUpdateInput>
    /**
     * Choose, which UserMessage to update.
     */
    where: UserMessageWhereUniqueInput
  }

  /**
   * UserMessage updateMany
   */
  export type UserMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserMessages.
     */
    data: XOR<UserMessageUpdateManyMutationInput, UserMessageUncheckedUpdateManyInput>
    /**
     * Filter which UserMessages to update
     */
    where?: UserMessageWhereInput
    /**
     * Limit how many UserMessages to update.
     */
    limit?: number
  }

  /**
   * UserMessage updateManyAndReturn
   */
  export type UserMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * The data used to update UserMessages.
     */
    data: XOR<UserMessageUpdateManyMutationInput, UserMessageUncheckedUpdateManyInput>
    /**
     * Filter which UserMessages to update
     */
    where?: UserMessageWhereInput
    /**
     * Limit how many UserMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserMessage upsert
   */
  export type UserMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the UserMessage to update in case it exists.
     */
    where: UserMessageWhereUniqueInput
    /**
     * In case the UserMessage found by the `where` argument doesn't exist, create a new UserMessage with this data.
     */
    create: XOR<UserMessageCreateInput, UserMessageUncheckedCreateInput>
    /**
     * In case the UserMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserMessageUpdateInput, UserMessageUncheckedUpdateInput>
  }

  /**
   * UserMessage delete
   */
  export type UserMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
    /**
     * Filter which UserMessage to delete.
     */
    where: UserMessageWhereUniqueInput
  }

  /**
   * UserMessage deleteMany
   */
  export type UserMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserMessages to delete
     */
    where?: UserMessageWhereInput
    /**
     * Limit how many UserMessages to delete.
     */
    limit?: number
  }

  /**
   * UserMessage without action
   */
  export type UserMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserMessage
     */
    select?: UserMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserMessage
     */
    omit?: UserMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserMessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
    post_id: number | null
    comment_id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
    post_id: number | null
    comment_id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    type: string | null
    sender_id: number | null
    receiver_id: number | null
    post_id: number | null
    comment_id: number | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    type: string | null
    sender_id: number | null
    receiver_id: number | null
    post_id: number | null
    comment_id: number | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    sender_id: number
    receiver_id: number
    post_id: number
    comment_id: number
    is_read: number
    created_at: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    post_id?: true
    comment_id?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    post_id?: true
    comment_id?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    sender_id?: true
    receiver_id?: true
    post_id?: true
    comment_id?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    sender_id?: true
    receiver_id?: true
    post_id?: true
    comment_id?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    sender_id?: true
    receiver_id?: true
    post_id?: true
    comment_id?: true
    is_read?: true
    created_at?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    type: string
    sender_id: number
    receiver_id: number
    post_id: number | null
    comment_id: number | null
    is_read: boolean
    created_at: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    post_id?: boolean
    comment_id?: boolean
    is_read?: boolean
    created_at?: boolean
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    post_id?: boolean
    comment_id?: boolean
    is_read?: boolean
    created_at?: boolean
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    post_id?: boolean
    comment_id?: boolean
    is_read?: boolean
    created_at?: boolean
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    post_id?: boolean
    comment_id?: boolean
    is_read?: boolean
    created_at?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "sender_id" | "receiver_id" | "post_id" | "comment_id" | "is_read" | "created_at", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | MemberDefaultArgs<ExtArgs>
    receiver?: boolean | MemberDefaultArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      sender: Prisma.$MemberPayload<ExtArgs>
      receiver: Prisma.$MemberPayload<ExtArgs>
      post: Prisma.$PostPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string
      sender_id: number
      receiver_id: number
      post_id: number | null
      comment_id: number | null
      is_read: boolean
      created_at: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends MemberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MemberDefaultArgs<ExtArgs>>): Prisma__MemberClient<$Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    post<T extends Notification$postArgs<ExtArgs> = {}>(args?: Subset<T, Notification$postArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comment<T extends Notification$commentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly sender_id: FieldRef<"Notification", 'Int'>
    readonly receiver_id: FieldRef<"Notification", 'Int'>
    readonly post_id: FieldRef<"Notification", 'Int'>
    readonly comment_id: FieldRef<"Notification", 'Int'>
    readonly is_read: FieldRef<"Notification", 'Boolean'>
    readonly created_at: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.post
   */
  export type Notification$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Notification.comment
   */
  export type Notification$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BoardScalarFieldEnum: {
    id: 'id',
    board_name: 'board_name',
    url_slug: 'url_slug',
    seq: 'seq'
  };

  export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    all_posts: 'all_posts',
    authority: 'authority',
    all_views: 'all_views',
    password: 'password',
    user_nickname: 'user_nickname',
    profile: 'profile',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    board_id: 'board_id',
    board_name: 'board_name',
    title: 'title',
    content: 'content',
    user_id: 'user_id',
    views: 'views',
    likes: 'likes',
    dislikes: 'dislikes',
    reports: 'reports',
    created_at: 'created_at',
    updated_at: 'updated_at',
    url_slug: 'url_slug',
    user_nickname: 'user_nickname',
    is_deleted: 'is_deleted'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    post_id: 'post_id',
    user_id: 'user_id',
    content: 'content',
    parent_id: 'parent_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    likes: 'likes',
    dislikes: 'dislikes',
    user_nickname: 'user_nickname',
    is_deleted: 'is_deleted',
    deleted_at: 'deleted_at'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const PostActionScalarFieldEnum: {
    id: 'id',
    post_id: 'post_id',
    user_id: 'user_id',
    action_type: 'action_type',
    created_at: 'created_at'
  };

  export type PostActionScalarFieldEnum = (typeof PostActionScalarFieldEnum)[keyof typeof PostActionScalarFieldEnum]


  export const CommentActionScalarFieldEnum: {
    id: 'id',
    comment_id: 'comment_id',
    user_id: 'user_id',
    action_type: 'action_type',
    reason: 'reason',
    created_at: 'created_at'
  };

  export type CommentActionScalarFieldEnum = (typeof CommentActionScalarFieldEnum)[keyof typeof CommentActionScalarFieldEnum]


  export const PostImageScalarFieldEnum: {
    id: 'id',
    post_id: 'post_id',
    image_url: 'image_url',
    created_at: 'created_at'
  };

  export type PostImageScalarFieldEnum = (typeof PostImageScalarFieldEnum)[keyof typeof PostImageScalarFieldEnum]


  export const BlockedUserScalarFieldEnum: {
    id: 'id',
    blockerId: 'blockerId',
    blockedId: 'blockedId',
    createdAt: 'createdAt'
  };

  export type BlockedUserScalarFieldEnum = (typeof BlockedUserScalarFieldEnum)[keyof typeof BlockedUserScalarFieldEnum]


  export const UserReportScalarFieldEnum: {
    id: 'id',
    reporterId: 'reporterId',
    reportedId: 'reportedId',
    reason: 'reason',
    createdAt: 'createdAt',
    type: 'type'
  };

  export type UserReportScalarFieldEnum = (typeof UserReportScalarFieldEnum)[keyof typeof UserReportScalarFieldEnum]


  export const UserMessageScalarFieldEnum: {
    id: 'id',
    sender_id: 'sender_id',
    receiver_id: 'receiver_id',
    content: 'content',
    isRead: 'isRead',
    createdAt: 'createdAt',
    is_deleted_by_sender: 'is_deleted_by_sender',
    is_deleted_by_receiver: 'is_deleted_by_receiver'
  };

  export type UserMessageScalarFieldEnum = (typeof UserMessageScalarFieldEnum)[keyof typeof UserMessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    sender_id: 'sender_id',
    receiver_id: 'receiver_id',
    post_id: 'post_id',
    comment_id: 'comment_id',
    is_read: 'is_read',
    created_at: 'created_at'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BoardWhereInput = {
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    id?: IntFilter<"Board"> | number
    board_name?: StringFilter<"Board"> | string
    url_slug?: StringFilter<"Board"> | string
    seq?: IntFilter<"Board"> | number
    posts?: PostListRelationFilter
  }

  export type BoardOrderByWithRelationInput = {
    id?: SortOrder
    board_name?: SortOrder
    url_slug?: SortOrder
    seq?: SortOrder
    posts?: PostOrderByRelationAggregateInput
  }

  export type BoardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    board_name?: string
    AND?: BoardWhereInput | BoardWhereInput[]
    OR?: BoardWhereInput[]
    NOT?: BoardWhereInput | BoardWhereInput[]
    url_slug?: StringFilter<"Board"> | string
    seq?: IntFilter<"Board"> | number
    posts?: PostListRelationFilter
  }, "id" | "board_name">

  export type BoardOrderByWithAggregationInput = {
    id?: SortOrder
    board_name?: SortOrder
    url_slug?: SortOrder
    seq?: SortOrder
    _count?: BoardCountOrderByAggregateInput
    _avg?: BoardAvgOrderByAggregateInput
    _max?: BoardMaxOrderByAggregateInput
    _min?: BoardMinOrderByAggregateInput
    _sum?: BoardSumOrderByAggregateInput
  }

  export type BoardScalarWhereWithAggregatesInput = {
    AND?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    OR?: BoardScalarWhereWithAggregatesInput[]
    NOT?: BoardScalarWhereWithAggregatesInput | BoardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Board"> | number
    board_name?: StringWithAggregatesFilter<"Board"> | string
    url_slug?: StringWithAggregatesFilter<"Board"> | string
    seq?: IntWithAggregatesFilter<"Board"> | number
  }

  export type MemberWhereInput = {
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    id?: IntFilter<"Member"> | number
    username?: StringFilter<"Member"> | string
    email?: StringFilter<"Member"> | string
    all_posts?: IntFilter<"Member"> | number
    authority?: IntFilter<"Member"> | number
    all_views?: IntFilter<"Member"> | number
    password?: StringFilter<"Member"> | string
    user_nickname?: StringNullableFilter<"Member"> | string | null
    profile?: StringNullableFilter<"Member"> | string | null
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    postActions?: PostActionListRelationFilter
    commentActions?: CommentActionListRelationFilter
    blockedBy?: BlockedUserListRelationFilter
    blockedUsers?: BlockedUserListRelationFilter
    reportedBy?: UserReportListRelationFilter
    reportedUsers?: UserReportListRelationFilter
    sentMessages?: UserMessageListRelationFilter
    receivedMessages?: UserMessageListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    receivedNotifications?: NotificationListRelationFilter
  }

  export type MemberOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    all_posts?: SortOrder
    authority?: SortOrder
    all_views?: SortOrder
    password?: SortOrder
    user_nickname?: SortOrderInput | SortOrder
    profile?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    postActions?: PostActionOrderByRelationAggregateInput
    commentActions?: CommentActionOrderByRelationAggregateInput
    blockedBy?: BlockedUserOrderByRelationAggregateInput
    blockedUsers?: BlockedUserOrderByRelationAggregateInput
    reportedBy?: UserReportOrderByRelationAggregateInput
    reportedUsers?: UserReportOrderByRelationAggregateInput
    sentMessages?: UserMessageOrderByRelationAggregateInput
    receivedMessages?: UserMessageOrderByRelationAggregateInput
    sentNotifications?: NotificationOrderByRelationAggregateInput
    receivedNotifications?: NotificationOrderByRelationAggregateInput
  }

  export type MemberWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    user_nickname?: string
    AND?: MemberWhereInput | MemberWhereInput[]
    OR?: MemberWhereInput[]
    NOT?: MemberWhereInput | MemberWhereInput[]
    all_posts?: IntFilter<"Member"> | number
    authority?: IntFilter<"Member"> | number
    all_views?: IntFilter<"Member"> | number
    password?: StringFilter<"Member"> | string
    profile?: StringNullableFilter<"Member"> | string | null
    createdAt?: DateTimeFilter<"Member"> | Date | string
    updatedAt?: DateTimeFilter<"Member"> | Date | string
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    postActions?: PostActionListRelationFilter
    commentActions?: CommentActionListRelationFilter
    blockedBy?: BlockedUserListRelationFilter
    blockedUsers?: BlockedUserListRelationFilter
    reportedBy?: UserReportListRelationFilter
    reportedUsers?: UserReportListRelationFilter
    sentMessages?: UserMessageListRelationFilter
    receivedMessages?: UserMessageListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    receivedNotifications?: NotificationListRelationFilter
  }, "id" | "username" | "email" | "user_nickname">

  export type MemberOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    all_posts?: SortOrder
    authority?: SortOrder
    all_views?: SortOrder
    password?: SortOrder
    user_nickname?: SortOrderInput | SortOrder
    profile?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MemberCountOrderByAggregateInput
    _avg?: MemberAvgOrderByAggregateInput
    _max?: MemberMaxOrderByAggregateInput
    _min?: MemberMinOrderByAggregateInput
    _sum?: MemberSumOrderByAggregateInput
  }

  export type MemberScalarWhereWithAggregatesInput = {
    AND?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    OR?: MemberScalarWhereWithAggregatesInput[]
    NOT?: MemberScalarWhereWithAggregatesInput | MemberScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Member"> | number
    username?: StringWithAggregatesFilter<"Member"> | string
    email?: StringWithAggregatesFilter<"Member"> | string
    all_posts?: IntWithAggregatesFilter<"Member"> | number
    authority?: IntWithAggregatesFilter<"Member"> | number
    all_views?: IntWithAggregatesFilter<"Member"> | number
    password?: StringWithAggregatesFilter<"Member"> | string
    user_nickname?: StringNullableWithAggregatesFilter<"Member"> | string | null
    profile?: StringNullableWithAggregatesFilter<"Member"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Member"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    board_id?: IntFilter<"Post"> | number
    board_name?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    user_id?: IntFilter<"Post"> | number
    views?: IntFilter<"Post"> | number
    likes?: IntFilter<"Post"> | number
    dislikes?: IntFilter<"Post"> | number
    reports?: IntFilter<"Post"> | number
    created_at?: DateTimeFilter<"Post"> | Date | string
    updated_at?: DateTimeFilter<"Post"> | Date | string
    url_slug?: StringFilter<"Post"> | string
    user_nickname?: StringNullableFilter<"Post"> | string | null
    is_deleted?: BoolFilter<"Post"> | boolean
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    comments?: CommentListRelationFilter
    postActions?: PostActionListRelationFilter
    images?: PostImageListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    board_id?: SortOrder
    board_name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    user_id?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    reports?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    url_slug?: SortOrder
    user_nickname?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    board?: BoardOrderByWithRelationInput
    author?: MemberOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    postActions?: PostActionOrderByRelationAggregateInput
    images?: PostImageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    board_id?: IntFilter<"Post"> | number
    board_name?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    user_id?: IntFilter<"Post"> | number
    views?: IntFilter<"Post"> | number
    likes?: IntFilter<"Post"> | number
    dislikes?: IntFilter<"Post"> | number
    reports?: IntFilter<"Post"> | number
    created_at?: DateTimeFilter<"Post"> | Date | string
    updated_at?: DateTimeFilter<"Post"> | Date | string
    url_slug?: StringFilter<"Post"> | string
    user_nickname?: StringNullableFilter<"Post"> | string | null
    is_deleted?: BoolFilter<"Post"> | boolean
    board?: XOR<BoardScalarRelationFilter, BoardWhereInput>
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    comments?: CommentListRelationFilter
    postActions?: PostActionListRelationFilter
    images?: PostImageListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    board_id?: SortOrder
    board_name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    user_id?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    reports?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    url_slug?: SortOrder
    user_nickname?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    board_id?: IntWithAggregatesFilter<"Post"> | number
    board_name?: StringWithAggregatesFilter<"Post"> | string
    title?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    user_id?: IntWithAggregatesFilter<"Post"> | number
    views?: IntWithAggregatesFilter<"Post"> | number
    likes?: IntWithAggregatesFilter<"Post"> | number
    dislikes?: IntWithAggregatesFilter<"Post"> | number
    reports?: IntWithAggregatesFilter<"Post"> | number
    created_at?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    url_slug?: StringWithAggregatesFilter<"Post"> | string
    user_nickname?: StringNullableWithAggregatesFilter<"Post"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"Post"> | boolean
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    post_id?: IntFilter<"Comment"> | number
    user_id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    parent_id?: IntNullableFilter<"Comment"> | number | null
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    likes?: IntFilter<"Comment"> | number
    dislikes?: IntFilter<"Comment"> | number
    user_nickname?: StringNullableFilter<"Comment"> | string | null
    is_deleted?: BoolFilter<"Comment"> | boolean
    deleted_at?: DateTimeNullableFilter<"Comment"> | Date | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    actions?: CommentActionListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    user_nickname?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    post?: PostOrderByWithRelationInput
    author?: MemberOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
    actions?: CommentActionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    post_id?: IntFilter<"Comment"> | number
    user_id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    parent_id?: IntNullableFilter<"Comment"> | number | null
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    likes?: IntFilter<"Comment"> | number
    dislikes?: IntFilter<"Comment"> | number
    user_nickname?: StringNullableFilter<"Comment"> | string | null
    is_deleted?: BoolFilter<"Comment"> | boolean
    deleted_at?: DateTimeNullableFilter<"Comment"> | Date | string | null
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    actions?: CommentActionListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    user_nickname?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    post_id?: IntWithAggregatesFilter<"Comment"> | number
    user_id?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringWithAggregatesFilter<"Comment"> | string
    parent_id?: IntNullableWithAggregatesFilter<"Comment"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    likes?: IntWithAggregatesFilter<"Comment"> | number
    dislikes?: IntWithAggregatesFilter<"Comment"> | number
    user_nickname?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"Comment"> | boolean
    deleted_at?: DateTimeNullableWithAggregatesFilter<"Comment"> | Date | string | null
  }

  export type PostActionWhereInput = {
    AND?: PostActionWhereInput | PostActionWhereInput[]
    OR?: PostActionWhereInput[]
    NOT?: PostActionWhereInput | PostActionWhereInput[]
    id?: IntFilter<"PostAction"> | number
    post_id?: IntFilter<"PostAction"> | number
    user_id?: IntFilter<"PostAction"> | number
    action_type?: StringFilter<"PostAction"> | string
    created_at?: DateTimeFilter<"PostAction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type PostActionOrderByWithRelationInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrder
    post?: PostOrderByWithRelationInput
    user?: MemberOrderByWithRelationInput
  }

  export type PostActionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    post_id_user_id_action_type?: PostActionPost_idUser_idAction_typeCompoundUniqueInput
    AND?: PostActionWhereInput | PostActionWhereInput[]
    OR?: PostActionWhereInput[]
    NOT?: PostActionWhereInput | PostActionWhereInput[]
    post_id?: IntFilter<"PostAction"> | number
    user_id?: IntFilter<"PostAction"> | number
    action_type?: StringFilter<"PostAction"> | string
    created_at?: DateTimeFilter<"PostAction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    user?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "post_id_user_id_action_type">

  export type PostActionOrderByWithAggregationInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrder
    _count?: PostActionCountOrderByAggregateInput
    _avg?: PostActionAvgOrderByAggregateInput
    _max?: PostActionMaxOrderByAggregateInput
    _min?: PostActionMinOrderByAggregateInput
    _sum?: PostActionSumOrderByAggregateInput
  }

  export type PostActionScalarWhereWithAggregatesInput = {
    AND?: PostActionScalarWhereWithAggregatesInput | PostActionScalarWhereWithAggregatesInput[]
    OR?: PostActionScalarWhereWithAggregatesInput[]
    NOT?: PostActionScalarWhereWithAggregatesInput | PostActionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PostAction"> | number
    post_id?: IntWithAggregatesFilter<"PostAction"> | number
    user_id?: IntWithAggregatesFilter<"PostAction"> | number
    action_type?: StringWithAggregatesFilter<"PostAction"> | string
    created_at?: DateTimeWithAggregatesFilter<"PostAction"> | Date | string
  }

  export type CommentActionWhereInput = {
    AND?: CommentActionWhereInput | CommentActionWhereInput[]
    OR?: CommentActionWhereInput[]
    NOT?: CommentActionWhereInput | CommentActionWhereInput[]
    id?: IntFilter<"CommentAction"> | number
    comment_id?: IntFilter<"CommentAction"> | number
    user_id?: IntFilter<"CommentAction"> | number
    action_type?: StringFilter<"CommentAction"> | string
    reason?: StringNullableFilter<"CommentAction"> | string | null
    created_at?: DateTimeFilter<"CommentAction"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type CommentActionOrderByWithRelationInput = {
    id?: SortOrder
    comment_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    comment?: CommentOrderByWithRelationInput
    user?: MemberOrderByWithRelationInput
  }

  export type CommentActionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    comment_id_user_id_action_type?: CommentActionComment_idUser_idAction_typeCompoundUniqueInput
    AND?: CommentActionWhereInput | CommentActionWhereInput[]
    OR?: CommentActionWhereInput[]
    NOT?: CommentActionWhereInput | CommentActionWhereInput[]
    comment_id?: IntFilter<"CommentAction"> | number
    user_id?: IntFilter<"CommentAction"> | number
    action_type?: StringFilter<"CommentAction"> | string
    reason?: StringNullableFilter<"CommentAction"> | string | null
    created_at?: DateTimeFilter<"CommentAction"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "comment_id_user_id_action_type">

  export type CommentActionOrderByWithAggregationInput = {
    id?: SortOrder
    comment_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    reason?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: CommentActionCountOrderByAggregateInput
    _avg?: CommentActionAvgOrderByAggregateInput
    _max?: CommentActionMaxOrderByAggregateInput
    _min?: CommentActionMinOrderByAggregateInput
    _sum?: CommentActionSumOrderByAggregateInput
  }

  export type CommentActionScalarWhereWithAggregatesInput = {
    AND?: CommentActionScalarWhereWithAggregatesInput | CommentActionScalarWhereWithAggregatesInput[]
    OR?: CommentActionScalarWhereWithAggregatesInput[]
    NOT?: CommentActionScalarWhereWithAggregatesInput | CommentActionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommentAction"> | number
    comment_id?: IntWithAggregatesFilter<"CommentAction"> | number
    user_id?: IntWithAggregatesFilter<"CommentAction"> | number
    action_type?: StringWithAggregatesFilter<"CommentAction"> | string
    reason?: StringNullableWithAggregatesFilter<"CommentAction"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CommentAction"> | Date | string
  }

  export type PostImageWhereInput = {
    AND?: PostImageWhereInput | PostImageWhereInput[]
    OR?: PostImageWhereInput[]
    NOT?: PostImageWhereInput | PostImageWhereInput[]
    id?: IntFilter<"PostImage"> | number
    post_id?: IntFilter<"PostImage"> | number
    image_url?: StringFilter<"PostImage"> | string
    created_at?: DateTimeFilter<"PostImage"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type PostImageOrderByWithRelationInput = {
    id?: SortOrder
    post_id?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type PostImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostImageWhereInput | PostImageWhereInput[]
    OR?: PostImageWhereInput[]
    NOT?: PostImageWhereInput | PostImageWhereInput[]
    post_id?: IntFilter<"PostImage"> | number
    image_url?: StringFilter<"PostImage"> | string
    created_at?: DateTimeFilter<"PostImage"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type PostImageOrderByWithAggregationInput = {
    id?: SortOrder
    post_id?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
    _count?: PostImageCountOrderByAggregateInput
    _avg?: PostImageAvgOrderByAggregateInput
    _max?: PostImageMaxOrderByAggregateInput
    _min?: PostImageMinOrderByAggregateInput
    _sum?: PostImageSumOrderByAggregateInput
  }

  export type PostImageScalarWhereWithAggregatesInput = {
    AND?: PostImageScalarWhereWithAggregatesInput | PostImageScalarWhereWithAggregatesInput[]
    OR?: PostImageScalarWhereWithAggregatesInput[]
    NOT?: PostImageScalarWhereWithAggregatesInput | PostImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PostImage"> | number
    post_id?: IntWithAggregatesFilter<"PostImage"> | number
    image_url?: StringWithAggregatesFilter<"PostImage"> | string
    created_at?: DateTimeWithAggregatesFilter<"PostImage"> | Date | string
  }

  export type BlockedUserWhereInput = {
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    id?: IntFilter<"BlockedUser"> | number
    blockerId?: IntFilter<"BlockedUser"> | number
    blockedId?: IntFilter<"BlockedUser"> | number
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
    blocker?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    blocked?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type BlockedUserOrderByWithRelationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
    blocker?: MemberOrderByWithRelationInput
    blocked?: MemberOrderByWithRelationInput
  }

  export type BlockedUserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    blockerId_blockedId?: BlockedUserBlockerIdBlockedIdCompoundUniqueInput
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    blockerId?: IntFilter<"BlockedUser"> | number
    blockedId?: IntFilter<"BlockedUser"> | number
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
    blocker?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    blocked?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id" | "blockerId_blockedId">

  export type BlockedUserOrderByWithAggregationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
    _count?: BlockedUserCountOrderByAggregateInput
    _avg?: BlockedUserAvgOrderByAggregateInput
    _max?: BlockedUserMaxOrderByAggregateInput
    _min?: BlockedUserMinOrderByAggregateInput
    _sum?: BlockedUserSumOrderByAggregateInput
  }

  export type BlockedUserScalarWhereWithAggregatesInput = {
    AND?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    OR?: BlockedUserScalarWhereWithAggregatesInput[]
    NOT?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlockedUser"> | number
    blockerId?: IntWithAggregatesFilter<"BlockedUser"> | number
    blockedId?: IntWithAggregatesFilter<"BlockedUser"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BlockedUser"> | Date | string
  }

  export type UserReportWhereInput = {
    AND?: UserReportWhereInput | UserReportWhereInput[]
    OR?: UserReportWhereInput[]
    NOT?: UserReportWhereInput | UserReportWhereInput[]
    id?: IntFilter<"UserReport"> | number
    reporterId?: IntFilter<"UserReport"> | number
    reportedId?: IntFilter<"UserReport"> | number
    reason?: StringFilter<"UserReport"> | string
    createdAt?: DateTimeFilter<"UserReport"> | Date | string
    type?: StringFilter<"UserReport"> | string
    reporter?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    reported?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type UserReportOrderByWithRelationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    reporter?: MemberOrderByWithRelationInput
    reported?: MemberOrderByWithRelationInput
  }

  export type UserReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserReportWhereInput | UserReportWhereInput[]
    OR?: UserReportWhereInput[]
    NOT?: UserReportWhereInput | UserReportWhereInput[]
    reporterId?: IntFilter<"UserReport"> | number
    reportedId?: IntFilter<"UserReport"> | number
    reason?: StringFilter<"UserReport"> | string
    createdAt?: DateTimeFilter<"UserReport"> | Date | string
    type?: StringFilter<"UserReport"> | string
    reporter?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    reported?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type UserReportOrderByWithAggregationInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    _count?: UserReportCountOrderByAggregateInput
    _avg?: UserReportAvgOrderByAggregateInput
    _max?: UserReportMaxOrderByAggregateInput
    _min?: UserReportMinOrderByAggregateInput
    _sum?: UserReportSumOrderByAggregateInput
  }

  export type UserReportScalarWhereWithAggregatesInput = {
    AND?: UserReportScalarWhereWithAggregatesInput | UserReportScalarWhereWithAggregatesInput[]
    OR?: UserReportScalarWhereWithAggregatesInput[]
    NOT?: UserReportScalarWhereWithAggregatesInput | UserReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserReport"> | number
    reporterId?: IntWithAggregatesFilter<"UserReport"> | number
    reportedId?: IntWithAggregatesFilter<"UserReport"> | number
    reason?: StringWithAggregatesFilter<"UserReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserReport"> | Date | string
    type?: StringWithAggregatesFilter<"UserReport"> | string
  }

  export type UserMessageWhereInput = {
    AND?: UserMessageWhereInput | UserMessageWhereInput[]
    OR?: UserMessageWhereInput[]
    NOT?: UserMessageWhereInput | UserMessageWhereInput[]
    id?: IntFilter<"UserMessage"> | number
    sender_id?: IntFilter<"UserMessage"> | number
    receiver_id?: IntFilter<"UserMessage"> | number
    content?: StringFilter<"UserMessage"> | string
    isRead?: BoolFilter<"UserMessage"> | boolean
    createdAt?: DateTimeFilter<"UserMessage"> | Date | string
    is_deleted_by_sender?: BoolFilter<"UserMessage"> | boolean
    is_deleted_by_receiver?: BoolFilter<"UserMessage"> | boolean
    sender?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    receiver?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }

  export type UserMessageOrderByWithRelationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    is_deleted_by_sender?: SortOrder
    is_deleted_by_receiver?: SortOrder
    sender?: MemberOrderByWithRelationInput
    receiver?: MemberOrderByWithRelationInput
  }

  export type UserMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserMessageWhereInput | UserMessageWhereInput[]
    OR?: UserMessageWhereInput[]
    NOT?: UserMessageWhereInput | UserMessageWhereInput[]
    sender_id?: IntFilter<"UserMessage"> | number
    receiver_id?: IntFilter<"UserMessage"> | number
    content?: StringFilter<"UserMessage"> | string
    isRead?: BoolFilter<"UserMessage"> | boolean
    createdAt?: DateTimeFilter<"UserMessage"> | Date | string
    is_deleted_by_sender?: BoolFilter<"UserMessage"> | boolean
    is_deleted_by_receiver?: BoolFilter<"UserMessage"> | boolean
    sender?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    receiver?: XOR<MemberScalarRelationFilter, MemberWhereInput>
  }, "id">

  export type UserMessageOrderByWithAggregationInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    is_deleted_by_sender?: SortOrder
    is_deleted_by_receiver?: SortOrder
    _count?: UserMessageCountOrderByAggregateInput
    _avg?: UserMessageAvgOrderByAggregateInput
    _max?: UserMessageMaxOrderByAggregateInput
    _min?: UserMessageMinOrderByAggregateInput
    _sum?: UserMessageSumOrderByAggregateInput
  }

  export type UserMessageScalarWhereWithAggregatesInput = {
    AND?: UserMessageScalarWhereWithAggregatesInput | UserMessageScalarWhereWithAggregatesInput[]
    OR?: UserMessageScalarWhereWithAggregatesInput[]
    NOT?: UserMessageScalarWhereWithAggregatesInput | UserMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserMessage"> | number
    sender_id?: IntWithAggregatesFilter<"UserMessage"> | number
    receiver_id?: IntWithAggregatesFilter<"UserMessage"> | number
    content?: StringWithAggregatesFilter<"UserMessage"> | string
    isRead?: BoolWithAggregatesFilter<"UserMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserMessage"> | Date | string
    is_deleted_by_sender?: BoolWithAggregatesFilter<"UserMessage"> | boolean
    is_deleted_by_receiver?: BoolWithAggregatesFilter<"UserMessage"> | boolean
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    sender_id?: IntFilter<"Notification"> | number
    receiver_id?: IntFilter<"Notification"> | number
    post_id?: IntNullableFilter<"Notification"> | number | null
    comment_id?: IntNullableFilter<"Notification"> | number | null
    is_read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
    sender?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    receiver?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    post_id?: SortOrderInput | SortOrder
    comment_id?: SortOrderInput | SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
    sender?: MemberOrderByWithRelationInput
    receiver?: MemberOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: StringFilter<"Notification"> | string
    sender_id?: IntFilter<"Notification"> | number
    receiver_id?: IntFilter<"Notification"> | number
    post_id?: IntNullableFilter<"Notification"> | number | null
    comment_id?: IntNullableFilter<"Notification"> | number | null
    is_read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
    sender?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    receiver?: XOR<MemberScalarRelationFilter, MemberWhereInput>
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    post_id?: SortOrderInput | SortOrder
    comment_id?: SortOrderInput | SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    type?: StringWithAggregatesFilter<"Notification"> | string
    sender_id?: IntWithAggregatesFilter<"Notification"> | number
    receiver_id?: IntWithAggregatesFilter<"Notification"> | number
    post_id?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    comment_id?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    is_read?: BoolWithAggregatesFilter<"Notification"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type BoardCreateInput = {
    board_name: string
    url_slug: string
    seq?: number
    posts?: PostCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateInput = {
    id?: number
    board_name: string
    url_slug: string
    seq?: number
    posts?: PostUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardUpdateInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    url_slug?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    posts?: PostUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    url_slug?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
    posts?: PostUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardCreateManyInput = {
    id?: number
    board_name: string
    url_slug: string
    seq?: number
  }

  export type BoardUpdateManyMutationInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    url_slug?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
  }

  export type BoardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    url_slug?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
  }

  export type MemberCreateInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type MemberCreateManyInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MemberUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MemberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    board_name: string
    title: string
    content: string
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    board?: BoardCreateNestedOneWithoutPostsInput
    author: MemberCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postActions?: PostActionCreateNestedManyWithoutPostInput
    images?: PostImageCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    board_id?: number
    board_name: string
    title: string
    content: string
    user_id: number
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutPostInput
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    board?: BoardUpdateOneRequiredWithoutPostsNestedInput
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postActions?: PostActionUpdateManyWithoutPostNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutPostNestedInput
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    board_id?: number
    board_name: string
    title: string
    content: string
    user_id: number
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
  }

  export type PostUpdateManyMutationInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentCreateInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
    actions?: CommentActionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    post_id: number
    user_id: number
    content: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
    actions?: CommentActionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    actions?: CommentActionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
    actions?: CommentActionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: number
    post_id: number
    user_id: number
    content: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostActionCreateInput = {
    action_type: string
    created_at?: Date | string
    post: PostCreateNestedOneWithoutPostActionsInput
    user: MemberCreateNestedOneWithoutPostActionsInput
  }

  export type PostActionUncheckedCreateInput = {
    id?: number
    post_id: number
    user_id: number
    action_type: string
    created_at?: Date | string
  }

  export type PostActionUpdateInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutPostActionsNestedInput
    user?: MemberUpdateOneRequiredWithoutPostActionsNestedInput
  }

  export type PostActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostActionCreateManyInput = {
    id?: number
    post_id: number
    user_id: number
    action_type: string
    created_at?: Date | string
  }

  export type PostActionUpdateManyMutationInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentActionCreateInput = {
    action_type: string
    reason?: string | null
    created_at?: Date | string
    comment: CommentCreateNestedOneWithoutActionsInput
    user: MemberCreateNestedOneWithoutCommentActionsInput
  }

  export type CommentActionUncheckedCreateInput = {
    id?: number
    comment_id: number
    user_id: number
    action_type: string
    reason?: string | null
    created_at?: Date | string
  }

  export type CommentActionUpdateInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutActionsNestedInput
    user?: MemberUpdateOneRequiredWithoutCommentActionsNestedInput
  }

  export type CommentActionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentActionCreateManyInput = {
    id?: number
    comment_id: number
    user_id: number
    action_type: string
    reason?: string | null
    created_at?: Date | string
  }

  export type CommentActionUpdateManyMutationInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentActionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageCreateInput = {
    image_url: string
    created_at?: Date | string
    post: PostCreateNestedOneWithoutImagesInput
  }

  export type PostImageUncheckedCreateInput = {
    id?: number
    post_id: number
    image_url: string
    created_at?: Date | string
  }

  export type PostImageUpdateInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutImagesNestedInput
  }

  export type PostImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageCreateManyInput = {
    id?: number
    post_id: number
    image_url: string
    created_at?: Date | string
  }

  export type PostImageUpdateManyMutationInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserCreateInput = {
    createdAt?: Date | string
    blocker: MemberCreateNestedOneWithoutBlockedByInput
    blocked: MemberCreateNestedOneWithoutBlockedUsersInput
  }

  export type BlockedUserUncheckedCreateInput = {
    id?: number
    blockerId: number
    blockedId: number
    createdAt?: Date | string
  }

  export type BlockedUserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: MemberUpdateOneRequiredWithoutBlockedByNestedInput
    blocked?: MemberUpdateOneRequiredWithoutBlockedUsersNestedInput
  }

  export type BlockedUserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockerId?: IntFieldUpdateOperationsInput | number
    blockedId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserCreateManyInput = {
    id?: number
    blockerId: number
    blockedId: number
    createdAt?: Date | string
  }

  export type BlockedUserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockerId?: IntFieldUpdateOperationsInput | number
    blockedId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserReportCreateInput = {
    reason: string
    createdAt?: Date | string
    type?: string
    reporter: MemberCreateNestedOneWithoutReportedByInput
    reported: MemberCreateNestedOneWithoutReportedUsersInput
  }

  export type UserReportUncheckedCreateInput = {
    id?: number
    reporterId: number
    reportedId: number
    reason: string
    createdAt?: Date | string
    type?: string
  }

  export type UserReportUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reporter?: MemberUpdateOneRequiredWithoutReportedByNestedInput
    reported?: MemberUpdateOneRequiredWithoutReportedUsersNestedInput
  }

  export type UserReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    reportedId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserReportCreateManyInput = {
    id?: number
    reporterId: number
    reportedId: number
    reason: string
    createdAt?: Date | string
    type?: string
  }

  export type UserReportUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    reportedId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserMessageCreateInput = {
    content: string
    isRead?: boolean
    createdAt?: Date | string
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
    sender: MemberCreateNestedOneWithoutSentMessagesInput
    receiver: MemberCreateNestedOneWithoutReceivedMessagesInput
  }

  export type UserMessageUncheckedCreateInput = {
    id?: number
    sender_id: number
    receiver_id: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
  }

  export type UserMessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
    sender?: MemberUpdateOneRequiredWithoutSentMessagesNestedInput
    receiver?: MemberUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type UserMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserMessageCreateManyInput = {
    id?: number
    sender_id: number
    receiver_id: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
  }

  export type UserMessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationCreateInput = {
    type: string
    is_read?: boolean
    created_at?: Date | string
    sender: MemberCreateNestedOneWithoutSentNotificationsInput
    receiver: MemberCreateNestedOneWithoutReceivedNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    type: string
    sender_id: number
    receiver_id: number
    post_id?: number | null
    comment_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: MemberUpdateOneRequiredWithoutSentNotificationsNestedInput
    receiver?: MemberUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    type: string
    sender_id: number
    receiver_id: number
    post_id?: number | null
    comment_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardCountOrderByAggregateInput = {
    id?: SortOrder
    board_name?: SortOrder
    url_slug?: SortOrder
    seq?: SortOrder
  }

  export type BoardAvgOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
  }

  export type BoardMaxOrderByAggregateInput = {
    id?: SortOrder
    board_name?: SortOrder
    url_slug?: SortOrder
    seq?: SortOrder
  }

  export type BoardMinOrderByAggregateInput = {
    id?: SortOrder
    board_name?: SortOrder
    url_slug?: SortOrder
    seq?: SortOrder
  }

  export type BoardSumOrderByAggregateInput = {
    id?: SortOrder
    seq?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type PostActionListRelationFilter = {
    every?: PostActionWhereInput
    some?: PostActionWhereInput
    none?: PostActionWhereInput
  }

  export type CommentActionListRelationFilter = {
    every?: CommentActionWhereInput
    some?: CommentActionWhereInput
    none?: CommentActionWhereInput
  }

  export type BlockedUserListRelationFilter = {
    every?: BlockedUserWhereInput
    some?: BlockedUserWhereInput
    none?: BlockedUserWhereInput
  }

  export type UserReportListRelationFilter = {
    every?: UserReportWhereInput
    some?: UserReportWhereInput
    none?: UserReportWhereInput
  }

  export type UserMessageListRelationFilter = {
    every?: UserMessageWhereInput
    some?: UserMessageWhereInput
    none?: UserMessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockedUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MemberCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    all_posts?: SortOrder
    authority?: SortOrder
    all_views?: SortOrder
    password?: SortOrder
    user_nickname?: SortOrder
    profile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberAvgOrderByAggregateInput = {
    id?: SortOrder
    all_posts?: SortOrder
    authority?: SortOrder
    all_views?: SortOrder
  }

  export type MemberMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    all_posts?: SortOrder
    authority?: SortOrder
    all_views?: SortOrder
    password?: SortOrder
    user_nickname?: SortOrder
    profile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    all_posts?: SortOrder
    authority?: SortOrder
    all_views?: SortOrder
    password?: SortOrder
    user_nickname?: SortOrder
    profile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MemberSumOrderByAggregateInput = {
    id?: SortOrder
    all_posts?: SortOrder
    authority?: SortOrder
    all_views?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type BoardScalarRelationFilter = {
    is?: BoardWhereInput
    isNot?: BoardWhereInput
  }

  export type MemberScalarRelationFilter = {
    is?: MemberWhereInput
    isNot?: MemberWhereInput
  }

  export type PostImageListRelationFilter = {
    every?: PostImageWhereInput
    some?: PostImageWhereInput
    none?: PostImageWhereInput
  }

  export type PostImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    board_name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    user_id?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    reports?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    url_slug?: SortOrder
    user_nickname?: SortOrder
    is_deleted?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    user_id?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    reports?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    board_name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    user_id?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    reports?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    url_slug?: SortOrder
    user_nickname?: SortOrder
    is_deleted?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    board_name?: SortOrder
    title?: SortOrder
    content?: SortOrder
    user_id?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    reports?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    url_slug?: SortOrder
    user_nickname?: SortOrder
    is_deleted?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    board_id?: SortOrder
    user_id?: SortOrder
    views?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    reports?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    user_nickname?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    parent_id?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    user_nickname?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    parent_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    user_nickname?: SortOrder
    is_deleted?: SortOrder
    deleted_at?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    parent_id?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PostActionPost_idUser_idAction_typeCompoundUniqueInput = {
    post_id: number
    user_id: number
    action_type: string
  }

  export type PostActionCountOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrder
  }

  export type PostActionAvgOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type PostActionMaxOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrder
  }

  export type PostActionMinOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    created_at?: SortOrder
  }

  export type PostActionSumOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentActionComment_idUser_idAction_typeCompoundUniqueInput = {
    comment_id: number
    user_id: number
    action_type: string
  }

  export type CommentActionCountOrderByAggregateInput = {
    id?: SortOrder
    comment_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
  }

  export type CommentActionAvgOrderByAggregateInput = {
    id?: SortOrder
    comment_id?: SortOrder
    user_id?: SortOrder
  }

  export type CommentActionMaxOrderByAggregateInput = {
    id?: SortOrder
    comment_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
  }

  export type CommentActionMinOrderByAggregateInput = {
    id?: SortOrder
    comment_id?: SortOrder
    user_id?: SortOrder
    action_type?: SortOrder
    reason?: SortOrder
    created_at?: SortOrder
  }

  export type CommentActionSumOrderByAggregateInput = {
    id?: SortOrder
    comment_id?: SortOrder
    user_id?: SortOrder
  }

  export type PostImageCountOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
  }

  export type PostImageAvgOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
  }

  export type PostImageMaxOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
  }

  export type PostImageMinOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    image_url?: SortOrder
    created_at?: SortOrder
  }

  export type PostImageSumOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
  }

  export type BlockedUserBlockerIdBlockedIdCompoundUniqueInput = {
    blockerId: number
    blockedId: number
  }

  export type BlockedUserCountOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserAvgOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
  }

  export type BlockedUserMaxOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserMinOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockedUserSumOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
  }

  export type UserReportCountOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type UserReportAvgOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedId?: SortOrder
  }

  export type UserReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type UserReportMinOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedId?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type UserReportSumOrderByAggregateInput = {
    id?: SortOrder
    reporterId?: SortOrder
    reportedId?: SortOrder
  }

  export type UserMessageCountOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    is_deleted_by_sender?: SortOrder
    is_deleted_by_receiver?: SortOrder
  }

  export type UserMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type UserMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    is_deleted_by_sender?: SortOrder
    is_deleted_by_receiver?: SortOrder
  }

  export type UserMessageMinOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    content?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    is_deleted_by_sender?: SortOrder
    is_deleted_by_receiver?: SortOrder
  }

  export type UserMessageSumOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type PostNullableScalarRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    post_id?: SortOrder
    comment_id?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    post_id?: SortOrder
    comment_id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    post_id?: SortOrder
    comment_id?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    post_id?: SortOrder
    comment_id?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    post_id?: SortOrder
    comment_id?: SortOrder
  }

  export type PostCreateNestedManyWithoutBoardInput = {
    create?: XOR<PostCreateWithoutBoardInput, PostUncheckedCreateWithoutBoardInput> | PostCreateWithoutBoardInput[] | PostUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: PostCreateOrConnectWithoutBoardInput | PostCreateOrConnectWithoutBoardInput[]
    createMany?: PostCreateManyBoardInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<PostCreateWithoutBoardInput, PostUncheckedCreateWithoutBoardInput> | PostCreateWithoutBoardInput[] | PostUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: PostCreateOrConnectWithoutBoardInput | PostCreateOrConnectWithoutBoardInput[]
    createMany?: PostCreateManyBoardInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PostUpdateManyWithoutBoardNestedInput = {
    create?: XOR<PostCreateWithoutBoardInput, PostUncheckedCreateWithoutBoardInput> | PostCreateWithoutBoardInput[] | PostUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: PostCreateOrConnectWithoutBoardInput | PostCreateOrConnectWithoutBoardInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutBoardInput | PostUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: PostCreateManyBoardInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutBoardInput | PostUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: PostUpdateManyWithWhereWithoutBoardInput | PostUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<PostCreateWithoutBoardInput, PostUncheckedCreateWithoutBoardInput> | PostCreateWithoutBoardInput[] | PostUncheckedCreateWithoutBoardInput[]
    connectOrCreate?: PostCreateOrConnectWithoutBoardInput | PostCreateOrConnectWithoutBoardInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutBoardInput | PostUpsertWithWhereUniqueWithoutBoardInput[]
    createMany?: PostCreateManyBoardInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutBoardInput | PostUpdateWithWhereUniqueWithoutBoardInput[]
    updateMany?: PostUpdateManyWithWhereWithoutBoardInput | PostUpdateManyWithWhereWithoutBoardInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostActionCreateNestedManyWithoutUserInput = {
    create?: XOR<PostActionCreateWithoutUserInput, PostActionUncheckedCreateWithoutUserInput> | PostActionCreateWithoutUserInput[] | PostActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostActionCreateOrConnectWithoutUserInput | PostActionCreateOrConnectWithoutUserInput[]
    createMany?: PostActionCreateManyUserInputEnvelope
    connect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
  }

  export type CommentActionCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentActionCreateWithoutUserInput, CommentActionUncheckedCreateWithoutUserInput> | CommentActionCreateWithoutUserInput[] | CommentActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentActionCreateOrConnectWithoutUserInput | CommentActionCreateOrConnectWithoutUserInput[]
    createMany?: CommentActionCreateManyUserInputEnvelope
    connect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
  }

  export type BlockedUserCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlockedUserCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type UserReportCreateNestedManyWithoutReporterInput = {
    create?: XOR<UserReportCreateWithoutReporterInput, UserReportUncheckedCreateWithoutReporterInput> | UserReportCreateWithoutReporterInput[] | UserReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: UserReportCreateOrConnectWithoutReporterInput | UserReportCreateOrConnectWithoutReporterInput[]
    createMany?: UserReportCreateManyReporterInputEnvelope
    connect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
  }

  export type UserReportCreateNestedManyWithoutReportedInput = {
    create?: XOR<UserReportCreateWithoutReportedInput, UserReportUncheckedCreateWithoutReportedInput> | UserReportCreateWithoutReportedInput[] | UserReportUncheckedCreateWithoutReportedInput[]
    connectOrCreate?: UserReportCreateOrConnectWithoutReportedInput | UserReportCreateOrConnectWithoutReportedInput[]
    createMany?: UserReportCreateManyReportedInputEnvelope
    connect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
  }

  export type UserMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<UserMessageCreateWithoutSenderInput, UserMessageUncheckedCreateWithoutSenderInput> | UserMessageCreateWithoutSenderInput[] | UserMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: UserMessageCreateOrConnectWithoutSenderInput | UserMessageCreateOrConnectWithoutSenderInput[]
    createMany?: UserMessageCreateManySenderInputEnvelope
    connect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
  }

  export type UserMessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<UserMessageCreateWithoutReceiverInput, UserMessageUncheckedCreateWithoutReceiverInput> | UserMessageCreateWithoutReceiverInput[] | UserMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: UserMessageCreateOrConnectWithoutReceiverInput | UserMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: UserMessageCreateManyReceiverInputEnvelope
    connect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutReceiverInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostActionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostActionCreateWithoutUserInput, PostActionUncheckedCreateWithoutUserInput> | PostActionCreateWithoutUserInput[] | PostActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostActionCreateOrConnectWithoutUserInput | PostActionCreateOrConnectWithoutUserInput[]
    createMany?: PostActionCreateManyUserInputEnvelope
    connect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
  }

  export type CommentActionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentActionCreateWithoutUserInput, CommentActionUncheckedCreateWithoutUserInput> | CommentActionCreateWithoutUserInput[] | CommentActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentActionCreateOrConnectWithoutUserInput | CommentActionCreateOrConnectWithoutUserInput[]
    createMany?: CommentActionCreateManyUserInputEnvelope
    connect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
  }

  export type BlockedUserUncheckedCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlockedUserUncheckedCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type UserReportUncheckedCreateNestedManyWithoutReporterInput = {
    create?: XOR<UserReportCreateWithoutReporterInput, UserReportUncheckedCreateWithoutReporterInput> | UserReportCreateWithoutReporterInput[] | UserReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: UserReportCreateOrConnectWithoutReporterInput | UserReportCreateOrConnectWithoutReporterInput[]
    createMany?: UserReportCreateManyReporterInputEnvelope
    connect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
  }

  export type UserReportUncheckedCreateNestedManyWithoutReportedInput = {
    create?: XOR<UserReportCreateWithoutReportedInput, UserReportUncheckedCreateWithoutReportedInput> | UserReportCreateWithoutReportedInput[] | UserReportUncheckedCreateWithoutReportedInput[]
    connectOrCreate?: UserReportCreateOrConnectWithoutReportedInput | UserReportCreateOrConnectWithoutReportedInput[]
    createMany?: UserReportCreateManyReportedInputEnvelope
    connect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
  }

  export type UserMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<UserMessageCreateWithoutSenderInput, UserMessageUncheckedCreateWithoutSenderInput> | UserMessageCreateWithoutSenderInput[] | UserMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: UserMessageCreateOrConnectWithoutSenderInput | UserMessageCreateOrConnectWithoutSenderInput[]
    createMany?: UserMessageCreateManySenderInputEnvelope
    connect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
  }

  export type UserMessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<UserMessageCreateWithoutReceiverInput, UserMessageUncheckedCreateWithoutReceiverInput> | UserMessageCreateWithoutReceiverInput[] | UserMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: UserMessageCreateOrConnectWithoutReceiverInput | UserMessageCreateOrConnectWithoutReceiverInput[]
    createMany?: UserMessageCreateManyReceiverInputEnvelope
    connect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostActionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostActionCreateWithoutUserInput, PostActionUncheckedCreateWithoutUserInput> | PostActionCreateWithoutUserInput[] | PostActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostActionCreateOrConnectWithoutUserInput | PostActionCreateOrConnectWithoutUserInput[]
    upsert?: PostActionUpsertWithWhereUniqueWithoutUserInput | PostActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostActionCreateManyUserInputEnvelope
    set?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    disconnect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    delete?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    connect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    update?: PostActionUpdateWithWhereUniqueWithoutUserInput | PostActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostActionUpdateManyWithWhereWithoutUserInput | PostActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostActionScalarWhereInput | PostActionScalarWhereInput[]
  }

  export type CommentActionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentActionCreateWithoutUserInput, CommentActionUncheckedCreateWithoutUserInput> | CommentActionCreateWithoutUserInput[] | CommentActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentActionCreateOrConnectWithoutUserInput | CommentActionCreateOrConnectWithoutUserInput[]
    upsert?: CommentActionUpsertWithWhereUniqueWithoutUserInput | CommentActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentActionCreateManyUserInputEnvelope
    set?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    disconnect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    delete?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    connect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    update?: CommentActionUpdateWithWhereUniqueWithoutUserInput | CommentActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentActionUpdateManyWithWhereWithoutUserInput | CommentActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentActionScalarWhereInput | CommentActionScalarWhereInput[]
  }

  export type BlockedUserUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockerInput | BlockedUserUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockerInput | BlockedUserUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockerInput | BlockedUserUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlockedUserUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockedInput | BlockedUserUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockedInput | BlockedUserUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockedInput | BlockedUserUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type UserReportUpdateManyWithoutReporterNestedInput = {
    create?: XOR<UserReportCreateWithoutReporterInput, UserReportUncheckedCreateWithoutReporterInput> | UserReportCreateWithoutReporterInput[] | UserReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: UserReportCreateOrConnectWithoutReporterInput | UserReportCreateOrConnectWithoutReporterInput[]
    upsert?: UserReportUpsertWithWhereUniqueWithoutReporterInput | UserReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: UserReportCreateManyReporterInputEnvelope
    set?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    disconnect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    delete?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    connect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    update?: UserReportUpdateWithWhereUniqueWithoutReporterInput | UserReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: UserReportUpdateManyWithWhereWithoutReporterInput | UserReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: UserReportScalarWhereInput | UserReportScalarWhereInput[]
  }

  export type UserReportUpdateManyWithoutReportedNestedInput = {
    create?: XOR<UserReportCreateWithoutReportedInput, UserReportUncheckedCreateWithoutReportedInput> | UserReportCreateWithoutReportedInput[] | UserReportUncheckedCreateWithoutReportedInput[]
    connectOrCreate?: UserReportCreateOrConnectWithoutReportedInput | UserReportCreateOrConnectWithoutReportedInput[]
    upsert?: UserReportUpsertWithWhereUniqueWithoutReportedInput | UserReportUpsertWithWhereUniqueWithoutReportedInput[]
    createMany?: UserReportCreateManyReportedInputEnvelope
    set?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    disconnect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    delete?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    connect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    update?: UserReportUpdateWithWhereUniqueWithoutReportedInput | UserReportUpdateWithWhereUniqueWithoutReportedInput[]
    updateMany?: UserReportUpdateManyWithWhereWithoutReportedInput | UserReportUpdateManyWithWhereWithoutReportedInput[]
    deleteMany?: UserReportScalarWhereInput | UserReportScalarWhereInput[]
  }

  export type UserMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<UserMessageCreateWithoutSenderInput, UserMessageUncheckedCreateWithoutSenderInput> | UserMessageCreateWithoutSenderInput[] | UserMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: UserMessageCreateOrConnectWithoutSenderInput | UserMessageCreateOrConnectWithoutSenderInput[]
    upsert?: UserMessageUpsertWithWhereUniqueWithoutSenderInput | UserMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: UserMessageCreateManySenderInputEnvelope
    set?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    disconnect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    delete?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    connect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    update?: UserMessageUpdateWithWhereUniqueWithoutSenderInput | UserMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: UserMessageUpdateManyWithWhereWithoutSenderInput | UserMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: UserMessageScalarWhereInput | UserMessageScalarWhereInput[]
  }

  export type UserMessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<UserMessageCreateWithoutReceiverInput, UserMessageUncheckedCreateWithoutReceiverInput> | UserMessageCreateWithoutReceiverInput[] | UserMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: UserMessageCreateOrConnectWithoutReceiverInput | UserMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: UserMessageUpsertWithWhereUniqueWithoutReceiverInput | UserMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: UserMessageCreateManyReceiverInputEnvelope
    set?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    disconnect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    delete?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    connect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    update?: UserMessageUpdateWithWhereUniqueWithoutReceiverInput | UserMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: UserMessageUpdateManyWithWhereWithoutReceiverInput | UserMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: UserMessageScalarWhereInput | UserMessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutReceiverInput | NotificationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutReceiverInput | NotificationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutReceiverInput | NotificationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostActionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostActionCreateWithoutUserInput, PostActionUncheckedCreateWithoutUserInput> | PostActionCreateWithoutUserInput[] | PostActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostActionCreateOrConnectWithoutUserInput | PostActionCreateOrConnectWithoutUserInput[]
    upsert?: PostActionUpsertWithWhereUniqueWithoutUserInput | PostActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostActionCreateManyUserInputEnvelope
    set?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    disconnect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    delete?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    connect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    update?: PostActionUpdateWithWhereUniqueWithoutUserInput | PostActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostActionUpdateManyWithWhereWithoutUserInput | PostActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostActionScalarWhereInput | PostActionScalarWhereInput[]
  }

  export type CommentActionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentActionCreateWithoutUserInput, CommentActionUncheckedCreateWithoutUserInput> | CommentActionCreateWithoutUserInput[] | CommentActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentActionCreateOrConnectWithoutUserInput | CommentActionCreateOrConnectWithoutUserInput[]
    upsert?: CommentActionUpsertWithWhereUniqueWithoutUserInput | CommentActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentActionCreateManyUserInputEnvelope
    set?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    disconnect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    delete?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    connect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    update?: CommentActionUpdateWithWhereUniqueWithoutUserInput | CommentActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentActionUpdateManyWithWhereWithoutUserInput | CommentActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentActionScalarWhereInput | CommentActionScalarWhereInput[]
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockerInput | BlockedUserUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockerInput | BlockedUserUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockerInput | BlockedUserUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockedInput | BlockedUserUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockedInput | BlockedUserUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockedInput | BlockedUserUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type UserReportUncheckedUpdateManyWithoutReporterNestedInput = {
    create?: XOR<UserReportCreateWithoutReporterInput, UserReportUncheckedCreateWithoutReporterInput> | UserReportCreateWithoutReporterInput[] | UserReportUncheckedCreateWithoutReporterInput[]
    connectOrCreate?: UserReportCreateOrConnectWithoutReporterInput | UserReportCreateOrConnectWithoutReporterInput[]
    upsert?: UserReportUpsertWithWhereUniqueWithoutReporterInput | UserReportUpsertWithWhereUniqueWithoutReporterInput[]
    createMany?: UserReportCreateManyReporterInputEnvelope
    set?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    disconnect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    delete?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    connect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    update?: UserReportUpdateWithWhereUniqueWithoutReporterInput | UserReportUpdateWithWhereUniqueWithoutReporterInput[]
    updateMany?: UserReportUpdateManyWithWhereWithoutReporterInput | UserReportUpdateManyWithWhereWithoutReporterInput[]
    deleteMany?: UserReportScalarWhereInput | UserReportScalarWhereInput[]
  }

  export type UserReportUncheckedUpdateManyWithoutReportedNestedInput = {
    create?: XOR<UserReportCreateWithoutReportedInput, UserReportUncheckedCreateWithoutReportedInput> | UserReportCreateWithoutReportedInput[] | UserReportUncheckedCreateWithoutReportedInput[]
    connectOrCreate?: UserReportCreateOrConnectWithoutReportedInput | UserReportCreateOrConnectWithoutReportedInput[]
    upsert?: UserReportUpsertWithWhereUniqueWithoutReportedInput | UserReportUpsertWithWhereUniqueWithoutReportedInput[]
    createMany?: UserReportCreateManyReportedInputEnvelope
    set?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    disconnect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    delete?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    connect?: UserReportWhereUniqueInput | UserReportWhereUniqueInput[]
    update?: UserReportUpdateWithWhereUniqueWithoutReportedInput | UserReportUpdateWithWhereUniqueWithoutReportedInput[]
    updateMany?: UserReportUpdateManyWithWhereWithoutReportedInput | UserReportUpdateManyWithWhereWithoutReportedInput[]
    deleteMany?: UserReportScalarWhereInput | UserReportScalarWhereInput[]
  }

  export type UserMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<UserMessageCreateWithoutSenderInput, UserMessageUncheckedCreateWithoutSenderInput> | UserMessageCreateWithoutSenderInput[] | UserMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: UserMessageCreateOrConnectWithoutSenderInput | UserMessageCreateOrConnectWithoutSenderInput[]
    upsert?: UserMessageUpsertWithWhereUniqueWithoutSenderInput | UserMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: UserMessageCreateManySenderInputEnvelope
    set?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    disconnect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    delete?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    connect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    update?: UserMessageUpdateWithWhereUniqueWithoutSenderInput | UserMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: UserMessageUpdateManyWithWhereWithoutSenderInput | UserMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: UserMessageScalarWhereInput | UserMessageScalarWhereInput[]
  }

  export type UserMessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<UserMessageCreateWithoutReceiverInput, UserMessageUncheckedCreateWithoutReceiverInput> | UserMessageCreateWithoutReceiverInput[] | UserMessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: UserMessageCreateOrConnectWithoutReceiverInput | UserMessageCreateOrConnectWithoutReceiverInput[]
    upsert?: UserMessageUpsertWithWhereUniqueWithoutReceiverInput | UserMessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: UserMessageCreateManyReceiverInputEnvelope
    set?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    disconnect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    delete?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    connect?: UserMessageWhereUniqueInput | UserMessageWhereUniqueInput[]
    update?: UserMessageUpdateWithWhereUniqueWithoutReceiverInput | UserMessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: UserMessageUpdateManyWithWhereWithoutReceiverInput | UserMessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: UserMessageScalarWhereInput | UserMessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput> | NotificationCreateWithoutReceiverInput[] | NotificationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutReceiverInput | NotificationCreateOrConnectWithoutReceiverInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutReceiverInput | NotificationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: NotificationCreateManyReceiverInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutReceiverInput | NotificationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutReceiverInput | NotificationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type BoardCreateNestedOneWithoutPostsInput = {
    create?: XOR<BoardCreateWithoutPostsInput, BoardUncheckedCreateWithoutPostsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutPostsInput
    connect?: BoardWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutPostsInput = {
    create?: XOR<MemberCreateWithoutPostsInput, MemberUncheckedCreateWithoutPostsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPostsInput
    connect?: MemberWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostActionCreateNestedManyWithoutPostInput = {
    create?: XOR<PostActionCreateWithoutPostInput, PostActionUncheckedCreateWithoutPostInput> | PostActionCreateWithoutPostInput[] | PostActionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostActionCreateOrConnectWithoutPostInput | PostActionCreateOrConnectWithoutPostInput[]
    createMany?: PostActionCreateManyPostInputEnvelope
    connect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
  }

  export type PostImageCreateNestedManyWithoutPostInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutPostInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostActionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostActionCreateWithoutPostInput, PostActionUncheckedCreateWithoutPostInput> | PostActionCreateWithoutPostInput[] | PostActionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostActionCreateOrConnectWithoutPostInput | PostActionCreateOrConnectWithoutPostInput[]
    createMany?: PostActionCreateManyPostInputEnvelope
    connect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
  }

  export type PostImageUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BoardUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<BoardCreateWithoutPostsInput, BoardUncheckedCreateWithoutPostsInput>
    connectOrCreate?: BoardCreateOrConnectWithoutPostsInput
    upsert?: BoardUpsertWithoutPostsInput
    connect?: BoardWhereUniqueInput
    update?: XOR<XOR<BoardUpdateToOneWithWhereWithoutPostsInput, BoardUpdateWithoutPostsInput>, BoardUncheckedUpdateWithoutPostsInput>
  }

  export type MemberUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<MemberCreateWithoutPostsInput, MemberUncheckedCreateWithoutPostsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPostsInput
    upsert?: MemberUpsertWithoutPostsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutPostsInput, MemberUpdateWithoutPostsInput>, MemberUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostActionUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostActionCreateWithoutPostInput, PostActionUncheckedCreateWithoutPostInput> | PostActionCreateWithoutPostInput[] | PostActionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostActionCreateOrConnectWithoutPostInput | PostActionCreateOrConnectWithoutPostInput[]
    upsert?: PostActionUpsertWithWhereUniqueWithoutPostInput | PostActionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostActionCreateManyPostInputEnvelope
    set?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    disconnect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    delete?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    connect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    update?: PostActionUpdateWithWhereUniqueWithoutPostInput | PostActionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostActionUpdateManyWithWhereWithoutPostInput | PostActionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostActionScalarWhereInput | PostActionScalarWhereInput[]
  }

  export type PostImageUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    upsert?: PostImageUpsertWithWhereUniqueWithoutPostInput | PostImageUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    set?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    disconnect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    delete?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    update?: PostImageUpdateWithWhereUniqueWithoutPostInput | PostImageUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostImageUpdateManyWithWhereWithoutPostInput | PostImageUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutPostNestedInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPostInput | NotificationUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPostInput | NotificationUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPostInput | NotificationUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostActionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostActionCreateWithoutPostInput, PostActionUncheckedCreateWithoutPostInput> | PostActionCreateWithoutPostInput[] | PostActionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostActionCreateOrConnectWithoutPostInput | PostActionCreateOrConnectWithoutPostInput[]
    upsert?: PostActionUpsertWithWhereUniqueWithoutPostInput | PostActionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostActionCreateManyPostInputEnvelope
    set?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    disconnect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    delete?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    connect?: PostActionWhereUniqueInput | PostActionWhereUniqueInput[]
    update?: PostActionUpdateWithWhereUniqueWithoutPostInput | PostActionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostActionUpdateManyWithWhereWithoutPostInput | PostActionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostActionScalarWhereInput | PostActionScalarWhereInput[]
  }

  export type PostImageUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput> | PostImageCreateWithoutPostInput[] | PostImageUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostImageCreateOrConnectWithoutPostInput | PostImageCreateOrConnectWithoutPostInput[]
    upsert?: PostImageUpsertWithWhereUniqueWithoutPostInput | PostImageUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostImageCreateManyPostInputEnvelope
    set?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    disconnect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    delete?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    connect?: PostImageWhereUniqueInput | PostImageWhereUniqueInput[]
    update?: PostImageUpdateWithWhereUniqueWithoutPostInput | PostImageUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostImageUpdateManyWithWhereWithoutPostInput | PostImageUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPostInput | NotificationUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPostInput | NotificationUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPostInput | NotificationUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutCommentsInput = {
    create?: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentsInput
    connect?: MemberWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentActionCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentActionCreateWithoutCommentInput, CommentActionUncheckedCreateWithoutCommentInput> | CommentActionCreateWithoutCommentInput[] | CommentActionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentActionCreateOrConnectWithoutCommentInput | CommentActionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentActionCreateManyCommentInputEnvelope
    connect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentActionUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentActionCreateWithoutCommentInput, CommentActionUncheckedCreateWithoutCommentInput> | CommentActionCreateWithoutCommentInput[] | CommentActionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentActionCreateOrConnectWithoutCommentInput | CommentActionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentActionCreateManyCommentInputEnvelope
    connect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type MemberUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentsInput
    upsert?: MemberUpsertWithoutCommentsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCommentsInput, MemberUpdateWithoutCommentsInput>, MemberUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentActionUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentActionCreateWithoutCommentInput, CommentActionUncheckedCreateWithoutCommentInput> | CommentActionCreateWithoutCommentInput[] | CommentActionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentActionCreateOrConnectWithoutCommentInput | CommentActionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentActionUpsertWithWhereUniqueWithoutCommentInput | CommentActionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentActionCreateManyCommentInputEnvelope
    set?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    disconnect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    delete?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    connect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    update?: CommentActionUpdateWithWhereUniqueWithoutCommentInput | CommentActionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentActionUpdateManyWithWhereWithoutCommentInput | CommentActionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentActionScalarWhereInput | CommentActionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCommentInput | NotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCommentInput | NotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCommentInput | NotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentActionUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentActionCreateWithoutCommentInput, CommentActionUncheckedCreateWithoutCommentInput> | CommentActionCreateWithoutCommentInput[] | CommentActionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentActionCreateOrConnectWithoutCommentInput | CommentActionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentActionUpsertWithWhereUniqueWithoutCommentInput | CommentActionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentActionCreateManyCommentInputEnvelope
    set?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    disconnect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    delete?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    connect?: CommentActionWhereUniqueInput | CommentActionWhereUniqueInput[]
    update?: CommentActionUpdateWithWhereUniqueWithoutCommentInput | CommentActionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentActionUpdateManyWithWhereWithoutCommentInput | CommentActionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentActionScalarWhereInput | CommentActionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCommentInput | NotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCommentInput | NotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCommentInput | NotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutPostActionsInput = {
    create?: XOR<PostCreateWithoutPostActionsInput, PostUncheckedCreateWithoutPostActionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostActionsInput
    connect?: PostWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutPostActionsInput = {
    create?: XOR<MemberCreateWithoutPostActionsInput, MemberUncheckedCreateWithoutPostActionsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPostActionsInput
    connect?: MemberWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutPostActionsNestedInput = {
    create?: XOR<PostCreateWithoutPostActionsInput, PostUncheckedCreateWithoutPostActionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostActionsInput
    upsert?: PostUpsertWithoutPostActionsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutPostActionsInput, PostUpdateWithoutPostActionsInput>, PostUncheckedUpdateWithoutPostActionsInput>
  }

  export type MemberUpdateOneRequiredWithoutPostActionsNestedInput = {
    create?: XOR<MemberCreateWithoutPostActionsInput, MemberUncheckedCreateWithoutPostActionsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutPostActionsInput
    upsert?: MemberUpsertWithoutPostActionsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutPostActionsInput, MemberUpdateWithoutPostActionsInput>, MemberUncheckedUpdateWithoutPostActionsInput>
  }

  export type CommentCreateNestedOneWithoutActionsInput = {
    create?: XOR<CommentCreateWithoutActionsInput, CommentUncheckedCreateWithoutActionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutActionsInput
    connect?: CommentWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutCommentActionsInput = {
    create?: XOR<MemberCreateWithoutCommentActionsInput, MemberUncheckedCreateWithoutCommentActionsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentActionsInput
    connect?: MemberWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<CommentCreateWithoutActionsInput, CommentUncheckedCreateWithoutActionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutActionsInput
    upsert?: CommentUpsertWithoutActionsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutActionsInput, CommentUpdateWithoutActionsInput>, CommentUncheckedUpdateWithoutActionsInput>
  }

  export type MemberUpdateOneRequiredWithoutCommentActionsNestedInput = {
    create?: XOR<MemberCreateWithoutCommentActionsInput, MemberUncheckedCreateWithoutCommentActionsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutCommentActionsInput
    upsert?: MemberUpsertWithoutCommentActionsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutCommentActionsInput, MemberUpdateWithoutCommentActionsInput>, MemberUncheckedUpdateWithoutCommentActionsInput>
  }

  export type PostCreateNestedOneWithoutImagesInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    connect?: PostWhereUniqueInput
  }

  export type PostUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    connectOrCreate?: PostCreateOrConnectWithoutImagesInput
    upsert?: PostUpsertWithoutImagesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutImagesInput, PostUpdateWithoutImagesInput>, PostUncheckedUpdateWithoutImagesInput>
  }

  export type MemberCreateNestedOneWithoutBlockedByInput = {
    create?: XOR<MemberCreateWithoutBlockedByInput, MemberUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBlockedByInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutBlockedUsersInput = {
    create?: XOR<MemberCreateWithoutBlockedUsersInput, MemberUncheckedCreateWithoutBlockedUsersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBlockedUsersInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutBlockedByNestedInput = {
    create?: XOR<MemberCreateWithoutBlockedByInput, MemberUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBlockedByInput
    upsert?: MemberUpsertWithoutBlockedByInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutBlockedByInput, MemberUpdateWithoutBlockedByInput>, MemberUncheckedUpdateWithoutBlockedByInput>
  }

  export type MemberUpdateOneRequiredWithoutBlockedUsersNestedInput = {
    create?: XOR<MemberCreateWithoutBlockedUsersInput, MemberUncheckedCreateWithoutBlockedUsersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutBlockedUsersInput
    upsert?: MemberUpsertWithoutBlockedUsersInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutBlockedUsersInput, MemberUpdateWithoutBlockedUsersInput>, MemberUncheckedUpdateWithoutBlockedUsersInput>
  }

  export type MemberCreateNestedOneWithoutReportedByInput = {
    create?: XOR<MemberCreateWithoutReportedByInput, MemberUncheckedCreateWithoutReportedByInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReportedByInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutReportedUsersInput = {
    create?: XOR<MemberCreateWithoutReportedUsersInput, MemberUncheckedCreateWithoutReportedUsersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReportedUsersInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutReportedByNestedInput = {
    create?: XOR<MemberCreateWithoutReportedByInput, MemberUncheckedCreateWithoutReportedByInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReportedByInput
    upsert?: MemberUpsertWithoutReportedByInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutReportedByInput, MemberUpdateWithoutReportedByInput>, MemberUncheckedUpdateWithoutReportedByInput>
  }

  export type MemberUpdateOneRequiredWithoutReportedUsersNestedInput = {
    create?: XOR<MemberCreateWithoutReportedUsersInput, MemberUncheckedCreateWithoutReportedUsersInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReportedUsersInput
    upsert?: MemberUpsertWithoutReportedUsersInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutReportedUsersInput, MemberUpdateWithoutReportedUsersInput>, MemberUncheckedUpdateWithoutReportedUsersInput>
  }

  export type MemberCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<MemberCreateWithoutSentMessagesInput, MemberUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSentMessagesInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<MemberCreateWithoutReceivedMessagesInput, MemberUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReceivedMessagesInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<MemberCreateWithoutSentMessagesInput, MemberUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSentMessagesInput
    upsert?: MemberUpsertWithoutSentMessagesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutSentMessagesInput, MemberUpdateWithoutSentMessagesInput>, MemberUncheckedUpdateWithoutSentMessagesInput>
  }

  export type MemberUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<MemberCreateWithoutReceivedMessagesInput, MemberUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReceivedMessagesInput
    upsert?: MemberUpsertWithoutReceivedMessagesInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutReceivedMessagesInput, MemberUpdateWithoutReceivedMessagesInput>, MemberUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type MemberCreateNestedOneWithoutSentNotificationsInput = {
    create?: XOR<MemberCreateWithoutSentNotificationsInput, MemberUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSentNotificationsInput
    connect?: MemberWhereUniqueInput
  }

  export type MemberCreateNestedOneWithoutReceivedNotificationsInput = {
    create?: XOR<MemberCreateWithoutReceivedNotificationsInput, MemberUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReceivedNotificationsInput
    connect?: MemberWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotificationsInput
    connect?: PostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotificationsInput
    connect?: CommentWhereUniqueInput
  }

  export type MemberUpdateOneRequiredWithoutSentNotificationsNestedInput = {
    create?: XOR<MemberCreateWithoutSentNotificationsInput, MemberUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutSentNotificationsInput
    upsert?: MemberUpsertWithoutSentNotificationsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutSentNotificationsInput, MemberUpdateWithoutSentNotificationsInput>, MemberUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type MemberUpdateOneRequiredWithoutReceivedNotificationsNestedInput = {
    create?: XOR<MemberCreateWithoutReceivedNotificationsInput, MemberUncheckedCreateWithoutReceivedNotificationsInput>
    connectOrCreate?: MemberCreateOrConnectWithoutReceivedNotificationsInput
    upsert?: MemberUpsertWithoutReceivedNotificationsInput
    connect?: MemberWhereUniqueInput
    update?: XOR<XOR<MemberUpdateToOneWithWhereWithoutReceivedNotificationsInput, MemberUpdateWithoutReceivedNotificationsInput>, MemberUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type PostUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotificationsInput
    upsert?: PostUpsertWithoutNotificationsInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutNotificationsInput, PostUpdateWithoutNotificationsInput>, PostUncheckedUpdateWithoutNotificationsInput>
  }

  export type CommentUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotificationsInput
    upsert?: CommentUpsertWithoutNotificationsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutNotificationsInput, CommentUpdateWithoutNotificationsInput>, CommentUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PostCreateWithoutBoardInput = {
    board_name: string
    title: string
    content: string
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    author: MemberCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postActions?: PostActionCreateNestedManyWithoutPostInput
    images?: PostImageCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutBoardInput = {
    id?: number
    board_name: string
    title: string
    content: string
    user_id: number
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutPostInput
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutBoardInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutBoardInput, PostUncheckedCreateWithoutBoardInput>
  }

  export type PostCreateManyBoardInputEnvelope = {
    data: PostCreateManyBoardInput | PostCreateManyBoardInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithWhereUniqueWithoutBoardInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutBoardInput, PostUncheckedUpdateWithoutBoardInput>
    create: XOR<PostCreateWithoutBoardInput, PostUncheckedCreateWithoutBoardInput>
  }

  export type PostUpdateWithWhereUniqueWithoutBoardInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutBoardInput, PostUncheckedUpdateWithoutBoardInput>
  }

  export type PostUpdateManyWithWhereWithoutBoardInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutBoardInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    board_id?: IntFilter<"Post"> | number
    board_name?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    user_id?: IntFilter<"Post"> | number
    views?: IntFilter<"Post"> | number
    likes?: IntFilter<"Post"> | number
    dislikes?: IntFilter<"Post"> | number
    reports?: IntFilter<"Post"> | number
    created_at?: DateTimeFilter<"Post"> | Date | string
    updated_at?: DateTimeFilter<"Post"> | Date | string
    url_slug?: StringFilter<"Post"> | string
    user_nickname?: StringNullableFilter<"Post"> | string | null
    is_deleted?: BoolFilter<"Post"> | boolean
  }

  export type PostCreateWithoutAuthorInput = {
    board_name: string
    title: string
    content: string
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    board?: BoardCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postActions?: PostActionCreateNestedManyWithoutPostInput
    images?: PostImageCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: number
    board_id?: number
    board_name: string
    title: string
    content: string
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutPostInput
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
    actions?: CommentActionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: number
    post_id: number
    content: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
    actions?: CommentActionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PostActionCreateWithoutUserInput = {
    action_type: string
    created_at?: Date | string
    post: PostCreateNestedOneWithoutPostActionsInput
  }

  export type PostActionUncheckedCreateWithoutUserInput = {
    id?: number
    post_id: number
    action_type: string
    created_at?: Date | string
  }

  export type PostActionCreateOrConnectWithoutUserInput = {
    where: PostActionWhereUniqueInput
    create: XOR<PostActionCreateWithoutUserInput, PostActionUncheckedCreateWithoutUserInput>
  }

  export type PostActionCreateManyUserInputEnvelope = {
    data: PostActionCreateManyUserInput | PostActionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentActionCreateWithoutUserInput = {
    action_type: string
    reason?: string | null
    created_at?: Date | string
    comment: CommentCreateNestedOneWithoutActionsInput
  }

  export type CommentActionUncheckedCreateWithoutUserInput = {
    id?: number
    comment_id: number
    action_type: string
    reason?: string | null
    created_at?: Date | string
  }

  export type CommentActionCreateOrConnectWithoutUserInput = {
    where: CommentActionWhereUniqueInput
    create: XOR<CommentActionCreateWithoutUserInput, CommentActionUncheckedCreateWithoutUserInput>
  }

  export type CommentActionCreateManyUserInputEnvelope = {
    data: CommentActionCreateManyUserInput | CommentActionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BlockedUserCreateWithoutBlockerInput = {
    createdAt?: Date | string
    blocked: MemberCreateNestedOneWithoutBlockedUsersInput
  }

  export type BlockedUserUncheckedCreateWithoutBlockerInput = {
    id?: number
    blockedId: number
    createdAt?: Date | string
  }

  export type BlockedUserCreateOrConnectWithoutBlockerInput = {
    where: BlockedUserWhereUniqueInput
    create: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput>
  }

  export type BlockedUserCreateManyBlockerInputEnvelope = {
    data: BlockedUserCreateManyBlockerInput | BlockedUserCreateManyBlockerInput[]
    skipDuplicates?: boolean
  }

  export type BlockedUserCreateWithoutBlockedInput = {
    createdAt?: Date | string
    blocker: MemberCreateNestedOneWithoutBlockedByInput
  }

  export type BlockedUserUncheckedCreateWithoutBlockedInput = {
    id?: number
    blockerId: number
    createdAt?: Date | string
  }

  export type BlockedUserCreateOrConnectWithoutBlockedInput = {
    where: BlockedUserWhereUniqueInput
    create: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput>
  }

  export type BlockedUserCreateManyBlockedInputEnvelope = {
    data: BlockedUserCreateManyBlockedInput | BlockedUserCreateManyBlockedInput[]
    skipDuplicates?: boolean
  }

  export type UserReportCreateWithoutReporterInput = {
    reason: string
    createdAt?: Date | string
    type?: string
    reported: MemberCreateNestedOneWithoutReportedUsersInput
  }

  export type UserReportUncheckedCreateWithoutReporterInput = {
    id?: number
    reportedId: number
    reason: string
    createdAt?: Date | string
    type?: string
  }

  export type UserReportCreateOrConnectWithoutReporterInput = {
    where: UserReportWhereUniqueInput
    create: XOR<UserReportCreateWithoutReporterInput, UserReportUncheckedCreateWithoutReporterInput>
  }

  export type UserReportCreateManyReporterInputEnvelope = {
    data: UserReportCreateManyReporterInput | UserReportCreateManyReporterInput[]
    skipDuplicates?: boolean
  }

  export type UserReportCreateWithoutReportedInput = {
    reason: string
    createdAt?: Date | string
    type?: string
    reporter: MemberCreateNestedOneWithoutReportedByInput
  }

  export type UserReportUncheckedCreateWithoutReportedInput = {
    id?: number
    reporterId: number
    reason: string
    createdAt?: Date | string
    type?: string
  }

  export type UserReportCreateOrConnectWithoutReportedInput = {
    where: UserReportWhereUniqueInput
    create: XOR<UserReportCreateWithoutReportedInput, UserReportUncheckedCreateWithoutReportedInput>
  }

  export type UserReportCreateManyReportedInputEnvelope = {
    data: UserReportCreateManyReportedInput | UserReportCreateManyReportedInput[]
    skipDuplicates?: boolean
  }

  export type UserMessageCreateWithoutSenderInput = {
    content: string
    isRead?: boolean
    createdAt?: Date | string
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
    receiver: MemberCreateNestedOneWithoutReceivedMessagesInput
  }

  export type UserMessageUncheckedCreateWithoutSenderInput = {
    id?: number
    receiver_id: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
  }

  export type UserMessageCreateOrConnectWithoutSenderInput = {
    where: UserMessageWhereUniqueInput
    create: XOR<UserMessageCreateWithoutSenderInput, UserMessageUncheckedCreateWithoutSenderInput>
  }

  export type UserMessageCreateManySenderInputEnvelope = {
    data: UserMessageCreateManySenderInput | UserMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type UserMessageCreateWithoutReceiverInput = {
    content: string
    isRead?: boolean
    createdAt?: Date | string
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
    sender: MemberCreateNestedOneWithoutSentMessagesInput
  }

  export type UserMessageUncheckedCreateWithoutReceiverInput = {
    id?: number
    sender_id: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
  }

  export type UserMessageCreateOrConnectWithoutReceiverInput = {
    where: UserMessageWhereUniqueInput
    create: XOR<UserMessageCreateWithoutReceiverInput, UserMessageUncheckedCreateWithoutReceiverInput>
  }

  export type UserMessageCreateManyReceiverInputEnvelope = {
    data: UserMessageCreateManyReceiverInput | UserMessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSenderInput = {
    type: string
    is_read?: boolean
    created_at?: Date | string
    receiver: MemberCreateNestedOneWithoutReceivedNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id?: number
    type: string
    receiver_id: number
    post_id?: number | null
    comment_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutReceiverInput = {
    type: string
    is_read?: boolean
    created_at?: Date | string
    sender: MemberCreateNestedOneWithoutSentNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutReceiverInput = {
    id?: number
    type: string
    sender_id: number
    post_id?: number | null
    comment_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutReceiverInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput>
  }

  export type NotificationCreateManyReceiverInputEnvelope = {
    data: NotificationCreateManyReceiverInput | NotificationCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    post_id?: IntFilter<"Comment"> | number
    user_id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    parent_id?: IntNullableFilter<"Comment"> | number | null
    created_at?: DateTimeFilter<"Comment"> | Date | string
    updated_at?: DateTimeFilter<"Comment"> | Date | string
    likes?: IntFilter<"Comment"> | number
    dislikes?: IntFilter<"Comment"> | number
    user_nickname?: StringNullableFilter<"Comment"> | string | null
    is_deleted?: BoolFilter<"Comment"> | boolean
    deleted_at?: DateTimeNullableFilter<"Comment"> | Date | string | null
  }

  export type PostActionUpsertWithWhereUniqueWithoutUserInput = {
    where: PostActionWhereUniqueInput
    update: XOR<PostActionUpdateWithoutUserInput, PostActionUncheckedUpdateWithoutUserInput>
    create: XOR<PostActionCreateWithoutUserInput, PostActionUncheckedCreateWithoutUserInput>
  }

  export type PostActionUpdateWithWhereUniqueWithoutUserInput = {
    where: PostActionWhereUniqueInput
    data: XOR<PostActionUpdateWithoutUserInput, PostActionUncheckedUpdateWithoutUserInput>
  }

  export type PostActionUpdateManyWithWhereWithoutUserInput = {
    where: PostActionScalarWhereInput
    data: XOR<PostActionUpdateManyMutationInput, PostActionUncheckedUpdateManyWithoutUserInput>
  }

  export type PostActionScalarWhereInput = {
    AND?: PostActionScalarWhereInput | PostActionScalarWhereInput[]
    OR?: PostActionScalarWhereInput[]
    NOT?: PostActionScalarWhereInput | PostActionScalarWhereInput[]
    id?: IntFilter<"PostAction"> | number
    post_id?: IntFilter<"PostAction"> | number
    user_id?: IntFilter<"PostAction"> | number
    action_type?: StringFilter<"PostAction"> | string
    created_at?: DateTimeFilter<"PostAction"> | Date | string
  }

  export type CommentActionUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentActionWhereUniqueInput
    update: XOR<CommentActionUpdateWithoutUserInput, CommentActionUncheckedUpdateWithoutUserInput>
    create: XOR<CommentActionCreateWithoutUserInput, CommentActionUncheckedCreateWithoutUserInput>
  }

  export type CommentActionUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentActionWhereUniqueInput
    data: XOR<CommentActionUpdateWithoutUserInput, CommentActionUncheckedUpdateWithoutUserInput>
  }

  export type CommentActionUpdateManyWithWhereWithoutUserInput = {
    where: CommentActionScalarWhereInput
    data: XOR<CommentActionUpdateManyMutationInput, CommentActionUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentActionScalarWhereInput = {
    AND?: CommentActionScalarWhereInput | CommentActionScalarWhereInput[]
    OR?: CommentActionScalarWhereInput[]
    NOT?: CommentActionScalarWhereInput | CommentActionScalarWhereInput[]
    id?: IntFilter<"CommentAction"> | number
    comment_id?: IntFilter<"CommentAction"> | number
    user_id?: IntFilter<"CommentAction"> | number
    action_type?: StringFilter<"CommentAction"> | string
    reason?: StringNullableFilter<"CommentAction"> | string | null
    created_at?: DateTimeFilter<"CommentAction"> | Date | string
  }

  export type BlockedUserUpsertWithWhereUniqueWithoutBlockerInput = {
    where: BlockedUserWhereUniqueInput
    update: XOR<BlockedUserUpdateWithoutBlockerInput, BlockedUserUncheckedUpdateWithoutBlockerInput>
    create: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput>
  }

  export type BlockedUserUpdateWithWhereUniqueWithoutBlockerInput = {
    where: BlockedUserWhereUniqueInput
    data: XOR<BlockedUserUpdateWithoutBlockerInput, BlockedUserUncheckedUpdateWithoutBlockerInput>
  }

  export type BlockedUserUpdateManyWithWhereWithoutBlockerInput = {
    where: BlockedUserScalarWhereInput
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyWithoutBlockerInput>
  }

  export type BlockedUserScalarWhereInput = {
    AND?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
    OR?: BlockedUserScalarWhereInput[]
    NOT?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
    id?: IntFilter<"BlockedUser"> | number
    blockerId?: IntFilter<"BlockedUser"> | number
    blockedId?: IntFilter<"BlockedUser"> | number
    createdAt?: DateTimeFilter<"BlockedUser"> | Date | string
  }

  export type BlockedUserUpsertWithWhereUniqueWithoutBlockedInput = {
    where: BlockedUserWhereUniqueInput
    update: XOR<BlockedUserUpdateWithoutBlockedInput, BlockedUserUncheckedUpdateWithoutBlockedInput>
    create: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput>
  }

  export type BlockedUserUpdateWithWhereUniqueWithoutBlockedInput = {
    where: BlockedUserWhereUniqueInput
    data: XOR<BlockedUserUpdateWithoutBlockedInput, BlockedUserUncheckedUpdateWithoutBlockedInput>
  }

  export type BlockedUserUpdateManyWithWhereWithoutBlockedInput = {
    where: BlockedUserScalarWhereInput
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyWithoutBlockedInput>
  }

  export type UserReportUpsertWithWhereUniqueWithoutReporterInput = {
    where: UserReportWhereUniqueInput
    update: XOR<UserReportUpdateWithoutReporterInput, UserReportUncheckedUpdateWithoutReporterInput>
    create: XOR<UserReportCreateWithoutReporterInput, UserReportUncheckedCreateWithoutReporterInput>
  }

  export type UserReportUpdateWithWhereUniqueWithoutReporterInput = {
    where: UserReportWhereUniqueInput
    data: XOR<UserReportUpdateWithoutReporterInput, UserReportUncheckedUpdateWithoutReporterInput>
  }

  export type UserReportUpdateManyWithWhereWithoutReporterInput = {
    where: UserReportScalarWhereInput
    data: XOR<UserReportUpdateManyMutationInput, UserReportUncheckedUpdateManyWithoutReporterInput>
  }

  export type UserReportScalarWhereInput = {
    AND?: UserReportScalarWhereInput | UserReportScalarWhereInput[]
    OR?: UserReportScalarWhereInput[]
    NOT?: UserReportScalarWhereInput | UserReportScalarWhereInput[]
    id?: IntFilter<"UserReport"> | number
    reporterId?: IntFilter<"UserReport"> | number
    reportedId?: IntFilter<"UserReport"> | number
    reason?: StringFilter<"UserReport"> | string
    createdAt?: DateTimeFilter<"UserReport"> | Date | string
    type?: StringFilter<"UserReport"> | string
  }

  export type UserReportUpsertWithWhereUniqueWithoutReportedInput = {
    where: UserReportWhereUniqueInput
    update: XOR<UserReportUpdateWithoutReportedInput, UserReportUncheckedUpdateWithoutReportedInput>
    create: XOR<UserReportCreateWithoutReportedInput, UserReportUncheckedCreateWithoutReportedInput>
  }

  export type UserReportUpdateWithWhereUniqueWithoutReportedInput = {
    where: UserReportWhereUniqueInput
    data: XOR<UserReportUpdateWithoutReportedInput, UserReportUncheckedUpdateWithoutReportedInput>
  }

  export type UserReportUpdateManyWithWhereWithoutReportedInput = {
    where: UserReportScalarWhereInput
    data: XOR<UserReportUpdateManyMutationInput, UserReportUncheckedUpdateManyWithoutReportedInput>
  }

  export type UserMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: UserMessageWhereUniqueInput
    update: XOR<UserMessageUpdateWithoutSenderInput, UserMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<UserMessageCreateWithoutSenderInput, UserMessageUncheckedCreateWithoutSenderInput>
  }

  export type UserMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: UserMessageWhereUniqueInput
    data: XOR<UserMessageUpdateWithoutSenderInput, UserMessageUncheckedUpdateWithoutSenderInput>
  }

  export type UserMessageUpdateManyWithWhereWithoutSenderInput = {
    where: UserMessageScalarWhereInput
    data: XOR<UserMessageUpdateManyMutationInput, UserMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type UserMessageScalarWhereInput = {
    AND?: UserMessageScalarWhereInput | UserMessageScalarWhereInput[]
    OR?: UserMessageScalarWhereInput[]
    NOT?: UserMessageScalarWhereInput | UserMessageScalarWhereInput[]
    id?: IntFilter<"UserMessage"> | number
    sender_id?: IntFilter<"UserMessage"> | number
    receiver_id?: IntFilter<"UserMessage"> | number
    content?: StringFilter<"UserMessage"> | string
    isRead?: BoolFilter<"UserMessage"> | boolean
    createdAt?: DateTimeFilter<"UserMessage"> | Date | string
    is_deleted_by_sender?: BoolFilter<"UserMessage"> | boolean
    is_deleted_by_receiver?: BoolFilter<"UserMessage"> | boolean
  }

  export type UserMessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: UserMessageWhereUniqueInput
    update: XOR<UserMessageUpdateWithoutReceiverInput, UserMessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<UserMessageCreateWithoutReceiverInput, UserMessageUncheckedCreateWithoutReceiverInput>
  }

  export type UserMessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: UserMessageWhereUniqueInput
    data: XOR<UserMessageUpdateWithoutReceiverInput, UserMessageUncheckedUpdateWithoutReceiverInput>
  }

  export type UserMessageUpdateManyWithWhereWithoutReceiverInput = {
    where: UserMessageScalarWhereInput
    data: XOR<UserMessageUpdateManyMutationInput, UserMessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    sender_id?: IntFilter<"Notification"> | number
    receiver_id?: IntFilter<"Notification"> | number
    post_id?: IntNullableFilter<"Notification"> | number | null
    comment_id?: IntNullableFilter<"Notification"> | number | null
    is_read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutReceiverInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutReceiverInput, NotificationUncheckedUpdateWithoutReceiverInput>
    create: XOR<NotificationCreateWithoutReceiverInput, NotificationUncheckedCreateWithoutReceiverInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutReceiverInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutReceiverInput, NotificationUncheckedUpdateWithoutReceiverInput>
  }

  export type NotificationUpdateManyWithWhereWithoutReceiverInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutReceiverInput>
  }

  export type BoardCreateWithoutPostsInput = {
    board_name: string
    url_slug: string
    seq?: number
  }

  export type BoardUncheckedCreateWithoutPostsInput = {
    id?: number
    board_name: string
    url_slug: string
    seq?: number
  }

  export type BoardCreateOrConnectWithoutPostsInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutPostsInput, BoardUncheckedCreateWithoutPostsInput>
  }

  export type MemberCreateWithoutPostsInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutPostsInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutPostsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutPostsInput, MemberUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    author: MemberCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
    actions?: CommentActionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: number
    user_id: number
    content: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
    actions?: CommentActionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostActionCreateWithoutPostInput = {
    action_type: string
    created_at?: Date | string
    user: MemberCreateNestedOneWithoutPostActionsInput
  }

  export type PostActionUncheckedCreateWithoutPostInput = {
    id?: number
    user_id: number
    action_type: string
    created_at?: Date | string
  }

  export type PostActionCreateOrConnectWithoutPostInput = {
    where: PostActionWhereUniqueInput
    create: XOR<PostActionCreateWithoutPostInput, PostActionUncheckedCreateWithoutPostInput>
  }

  export type PostActionCreateManyPostInputEnvelope = {
    data: PostActionCreateManyPostInput | PostActionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostImageCreateWithoutPostInput = {
    image_url: string
    created_at?: Date | string
  }

  export type PostImageUncheckedCreateWithoutPostInput = {
    id?: number
    image_url: string
    created_at?: Date | string
  }

  export type PostImageCreateOrConnectWithoutPostInput = {
    where: PostImageWhereUniqueInput
    create: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput>
  }

  export type PostImageCreateManyPostInputEnvelope = {
    data: PostImageCreateManyPostInput | PostImageCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutPostInput = {
    type: string
    is_read?: boolean
    created_at?: Date | string
    sender: MemberCreateNestedOneWithoutSentNotificationsInput
    receiver: MemberCreateNestedOneWithoutReceivedNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutPostInput = {
    id?: number
    type: string
    sender_id: number
    receiver_id: number
    comment_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutPostInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput>
  }

  export type NotificationCreateManyPostInputEnvelope = {
    data: NotificationCreateManyPostInput | NotificationCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithoutPostsInput = {
    update: XOR<BoardUpdateWithoutPostsInput, BoardUncheckedUpdateWithoutPostsInput>
    create: XOR<BoardCreateWithoutPostsInput, BoardUncheckedCreateWithoutPostsInput>
    where?: BoardWhereInput
  }

  export type BoardUpdateToOneWithWhereWithoutPostsInput = {
    where?: BoardWhereInput
    data: XOR<BoardUpdateWithoutPostsInput, BoardUncheckedUpdateWithoutPostsInput>
  }

  export type BoardUpdateWithoutPostsInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    url_slug?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
  }

  export type BoardUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    url_slug?: StringFieldUpdateOperationsInput | string
    seq?: IntFieldUpdateOperationsInput | number
  }

  export type MemberUpsertWithoutPostsInput = {
    update: XOR<MemberUpdateWithoutPostsInput, MemberUncheckedUpdateWithoutPostsInput>
    create: XOR<MemberCreateWithoutPostsInput, MemberUncheckedCreateWithoutPostsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutPostsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutPostsInput, MemberUncheckedUpdateWithoutPostsInput>
  }

  export type MemberUpdateWithoutPostsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostActionUpsertWithWhereUniqueWithoutPostInput = {
    where: PostActionWhereUniqueInput
    update: XOR<PostActionUpdateWithoutPostInput, PostActionUncheckedUpdateWithoutPostInput>
    create: XOR<PostActionCreateWithoutPostInput, PostActionUncheckedCreateWithoutPostInput>
  }

  export type PostActionUpdateWithWhereUniqueWithoutPostInput = {
    where: PostActionWhereUniqueInput
    data: XOR<PostActionUpdateWithoutPostInput, PostActionUncheckedUpdateWithoutPostInput>
  }

  export type PostActionUpdateManyWithWhereWithoutPostInput = {
    where: PostActionScalarWhereInput
    data: XOR<PostActionUpdateManyMutationInput, PostActionUncheckedUpdateManyWithoutPostInput>
  }

  export type PostImageUpsertWithWhereUniqueWithoutPostInput = {
    where: PostImageWhereUniqueInput
    update: XOR<PostImageUpdateWithoutPostInput, PostImageUncheckedUpdateWithoutPostInput>
    create: XOR<PostImageCreateWithoutPostInput, PostImageUncheckedCreateWithoutPostInput>
  }

  export type PostImageUpdateWithWhereUniqueWithoutPostInput = {
    where: PostImageWhereUniqueInput
    data: XOR<PostImageUpdateWithoutPostInput, PostImageUncheckedUpdateWithoutPostInput>
  }

  export type PostImageUpdateManyWithWhereWithoutPostInput = {
    where: PostImageScalarWhereInput
    data: XOR<PostImageUpdateManyMutationInput, PostImageUncheckedUpdateManyWithoutPostInput>
  }

  export type PostImageScalarWhereInput = {
    AND?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
    OR?: PostImageScalarWhereInput[]
    NOT?: PostImageScalarWhereInput | PostImageScalarWhereInput[]
    id?: IntFilter<"PostImage"> | number
    post_id?: IntFilter<"PostImage"> | number
    image_url?: StringFilter<"PostImage"> | string
    created_at?: DateTimeFilter<"PostImage"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutPostInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutPostInput, NotificationUncheckedUpdateWithoutPostInput>
    create: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutPostInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutPostInput, NotificationUncheckedUpdateWithoutPostInput>
  }

  export type NotificationUpdateManyWithWhereWithoutPostInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutCommentsInput = {
    board_name: string
    title: string
    content: string
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    board?: BoardCreateNestedOneWithoutPostsInput
    author: MemberCreateNestedOneWithoutPostsInput
    postActions?: PostActionCreateNestedManyWithoutPostInput
    images?: PostImageCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: number
    board_id?: number
    board_name: string
    title: string
    content: string
    user_id: number
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    postActions?: PostActionUncheckedCreateNestedManyWithoutPostInput
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type MemberCreateWithoutCommentsInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutCommentsInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutCommentsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    actions?: CommentActionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: number
    post_id: number
    user_id: number
    content: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    actions?: CommentActionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentInput
    actions?: CommentActionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: number
    post_id: number
    user_id: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
    actions?: CommentActionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CommentActionCreateWithoutCommentInput = {
    action_type: string
    reason?: string | null
    created_at?: Date | string
    user: MemberCreateNestedOneWithoutCommentActionsInput
  }

  export type CommentActionUncheckedCreateWithoutCommentInput = {
    id?: number
    user_id: number
    action_type: string
    reason?: string | null
    created_at?: Date | string
  }

  export type CommentActionCreateOrConnectWithoutCommentInput = {
    where: CommentActionWhereUniqueInput
    create: XOR<CommentActionCreateWithoutCommentInput, CommentActionUncheckedCreateWithoutCommentInput>
  }

  export type CommentActionCreateManyCommentInputEnvelope = {
    data: CommentActionCreateManyCommentInput | CommentActionCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutCommentInput = {
    type: string
    is_read?: boolean
    created_at?: Date | string
    sender: MemberCreateNestedOneWithoutSentNotificationsInput
    receiver: MemberCreateNestedOneWithoutReceivedNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCommentInput = {
    id?: number
    type: string
    sender_id: number
    receiver_id: number
    post_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput>
  }

  export type NotificationCreateManyCommentInputEnvelope = {
    data: NotificationCreateManyCommentInput | NotificationCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    board?: BoardUpdateOneRequiredWithoutPostsNestedInput
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    postActions?: PostActionUpdateManyWithoutPostNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    postActions?: PostActionUncheckedUpdateManyWithoutPostNestedInput
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type MemberUpsertWithoutCommentsInput = {
    update: XOR<MemberUpdateWithoutCommentsInput, MemberUncheckedUpdateWithoutCommentsInput>
    create: XOR<MemberCreateWithoutCommentsInput, MemberUncheckedCreateWithoutCommentsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCommentsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCommentsInput, MemberUncheckedUpdateWithoutCommentsInput>
  }

  export type MemberUpdateWithoutCommentsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    actions?: CommentActionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actions?: CommentActionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type CommentActionUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentActionWhereUniqueInput
    update: XOR<CommentActionUpdateWithoutCommentInput, CommentActionUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentActionCreateWithoutCommentInput, CommentActionUncheckedCreateWithoutCommentInput>
  }

  export type CommentActionUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentActionWhereUniqueInput
    data: XOR<CommentActionUpdateWithoutCommentInput, CommentActionUncheckedUpdateWithoutCommentInput>
  }

  export type CommentActionUpdateManyWithWhereWithoutCommentInput = {
    where: CommentActionScalarWhereInput
    data: XOR<CommentActionUpdateManyMutationInput, CommentActionUncheckedUpdateManyWithoutCommentInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCommentInput, NotificationUncheckedUpdateWithoutCommentInput>
    create: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCommentInput, NotificationUncheckedUpdateWithoutCommentInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCommentInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCommentInput>
  }

  export type PostCreateWithoutPostActionsInput = {
    board_name: string
    title: string
    content: string
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    board?: BoardCreateNestedOneWithoutPostsInput
    author: MemberCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    images?: PostImageCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPostActionsInput = {
    id?: number
    board_id?: number
    board_name: string
    title: string
    content: string
    user_id: number
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPostActionsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostActionsInput, PostUncheckedCreateWithoutPostActionsInput>
  }

  export type MemberCreateWithoutPostActionsInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutPostActionsInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutPostActionsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutPostActionsInput, MemberUncheckedCreateWithoutPostActionsInput>
  }

  export type PostUpsertWithoutPostActionsInput = {
    update: XOR<PostUpdateWithoutPostActionsInput, PostUncheckedUpdateWithoutPostActionsInput>
    create: XOR<PostCreateWithoutPostActionsInput, PostUncheckedCreateWithoutPostActionsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutPostActionsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutPostActionsInput, PostUncheckedUpdateWithoutPostActionsInput>
  }

  export type PostUpdateWithoutPostActionsInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    board?: BoardUpdateOneRequiredWithoutPostsNestedInput
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPostActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type MemberUpsertWithoutPostActionsInput = {
    update: XOR<MemberUpdateWithoutPostActionsInput, MemberUncheckedUpdateWithoutPostActionsInput>
    create: XOR<MemberCreateWithoutPostActionsInput, MemberUncheckedCreateWithoutPostActionsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutPostActionsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutPostActionsInput, MemberUncheckedUpdateWithoutPostActionsInput>
  }

  export type MemberUpdateWithoutPostActionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutPostActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type CommentCreateWithoutActionsInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutActionsInput = {
    id?: number
    post_id: number
    user_id: number
    content: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutActionsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutActionsInput, CommentUncheckedCreateWithoutActionsInput>
  }

  export type MemberCreateWithoutCommentActionsInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutCommentActionsInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutCommentActionsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutCommentActionsInput, MemberUncheckedCreateWithoutCommentActionsInput>
  }

  export type CommentUpsertWithoutActionsInput = {
    update: XOR<CommentUpdateWithoutActionsInput, CommentUncheckedUpdateWithoutActionsInput>
    create: XOR<CommentCreateWithoutActionsInput, CommentUncheckedCreateWithoutActionsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutActionsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutActionsInput, CommentUncheckedUpdateWithoutActionsInput>
  }

  export type CommentUpdateWithoutActionsInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type MemberUpsertWithoutCommentActionsInput = {
    update: XOR<MemberUpdateWithoutCommentActionsInput, MemberUncheckedUpdateWithoutCommentActionsInput>
    create: XOR<MemberCreateWithoutCommentActionsInput, MemberUncheckedCreateWithoutCommentActionsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutCommentActionsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutCommentActionsInput, MemberUncheckedUpdateWithoutCommentActionsInput>
  }

  export type MemberUpdateWithoutCommentActionsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutCommentActionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type PostCreateWithoutImagesInput = {
    board_name: string
    title: string
    content: string
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    board?: BoardCreateNestedOneWithoutPostsInput
    author: MemberCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postActions?: PostActionCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutImagesInput = {
    id?: number
    board_id?: number
    board_name: string
    title: string
    content: string
    user_id: number
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutImagesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
  }

  export type PostUpsertWithoutImagesInput = {
    update: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
    create: XOR<PostCreateWithoutImagesInput, PostUncheckedCreateWithoutImagesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutImagesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutImagesInput, PostUncheckedUpdateWithoutImagesInput>
  }

  export type PostUpdateWithoutImagesInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    board?: BoardUpdateOneRequiredWithoutPostsNestedInput
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postActions?: PostActionUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type MemberCreateWithoutBlockedByInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutBlockedByInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutBlockedByInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutBlockedByInput, MemberUncheckedCreateWithoutBlockedByInput>
  }

  export type MemberCreateWithoutBlockedUsersInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutBlockedUsersInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutBlockedUsersInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutBlockedUsersInput, MemberUncheckedCreateWithoutBlockedUsersInput>
  }

  export type MemberUpsertWithoutBlockedByInput = {
    update: XOR<MemberUpdateWithoutBlockedByInput, MemberUncheckedUpdateWithoutBlockedByInput>
    create: XOR<MemberCreateWithoutBlockedByInput, MemberUncheckedCreateWithoutBlockedByInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutBlockedByInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutBlockedByInput, MemberUncheckedUpdateWithoutBlockedByInput>
  }

  export type MemberUpdateWithoutBlockedByInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutBlockedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUpsertWithoutBlockedUsersInput = {
    update: XOR<MemberUpdateWithoutBlockedUsersInput, MemberUncheckedUpdateWithoutBlockedUsersInput>
    create: XOR<MemberCreateWithoutBlockedUsersInput, MemberUncheckedCreateWithoutBlockedUsersInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutBlockedUsersInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutBlockedUsersInput, MemberUncheckedUpdateWithoutBlockedUsersInput>
  }

  export type MemberUpdateWithoutBlockedUsersInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutBlockedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type MemberCreateWithoutReportedByInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutReportedByInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutReportedByInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutReportedByInput, MemberUncheckedCreateWithoutReportedByInput>
  }

  export type MemberCreateWithoutReportedUsersInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutReportedUsersInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutReportedUsersInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutReportedUsersInput, MemberUncheckedCreateWithoutReportedUsersInput>
  }

  export type MemberUpsertWithoutReportedByInput = {
    update: XOR<MemberUpdateWithoutReportedByInput, MemberUncheckedUpdateWithoutReportedByInput>
    create: XOR<MemberCreateWithoutReportedByInput, MemberUncheckedCreateWithoutReportedByInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutReportedByInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutReportedByInput, MemberUncheckedUpdateWithoutReportedByInput>
  }

  export type MemberUpdateWithoutReportedByInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutReportedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUpsertWithoutReportedUsersInput = {
    update: XOR<MemberUpdateWithoutReportedUsersInput, MemberUncheckedUpdateWithoutReportedUsersInput>
    create: XOR<MemberCreateWithoutReportedUsersInput, MemberUncheckedCreateWithoutReportedUsersInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutReportedUsersInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutReportedUsersInput, MemberUncheckedUpdateWithoutReportedUsersInput>
  }

  export type MemberUpdateWithoutReportedUsersInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutReportedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type MemberCreateWithoutSentMessagesInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutSentMessagesInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutSentMessagesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutSentMessagesInput, MemberUncheckedCreateWithoutSentMessagesInput>
  }

  export type MemberCreateWithoutReceivedMessagesInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutReceivedMessagesInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutReceivedMessagesInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutReceivedMessagesInput, MemberUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type MemberUpsertWithoutSentMessagesInput = {
    update: XOR<MemberUpdateWithoutSentMessagesInput, MemberUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<MemberCreateWithoutSentMessagesInput, MemberUncheckedCreateWithoutSentMessagesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutSentMessagesInput, MemberUncheckedUpdateWithoutSentMessagesInput>
  }

  export type MemberUpdateWithoutSentMessagesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutSentMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUpsertWithoutReceivedMessagesInput = {
    update: XOR<MemberUpdateWithoutReceivedMessagesInput, MemberUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<MemberCreateWithoutReceivedMessagesInput, MemberUncheckedCreateWithoutReceivedMessagesInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutReceivedMessagesInput, MemberUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type MemberUpdateWithoutReceivedMessagesInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type MemberCreateWithoutSentNotificationsInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    receivedNotifications?: NotificationCreateNestedManyWithoutReceiverInput
  }

  export type MemberUncheckedCreateWithoutSentNotificationsInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    receivedNotifications?: NotificationUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type MemberCreateOrConnectWithoutSentNotificationsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutSentNotificationsInput, MemberUncheckedCreateWithoutSentNotificationsInput>
  }

  export type MemberCreateWithoutReceivedNotificationsInput = {
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    postActions?: PostActionCreateNestedManyWithoutUserInput
    commentActions?: CommentActionCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
  }

  export type MemberUncheckedCreateWithoutReceivedNotificationsInput = {
    id?: number
    username: string
    email: string
    all_posts?: number
    authority?: number
    all_views?: number
    password: string
    user_nickname?: string | null
    profile?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutUserInput
    commentActions?: CommentActionUncheckedCreateNestedManyWithoutUserInput
    blockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    blockedUsers?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    reportedBy?: UserReportUncheckedCreateNestedManyWithoutReporterInput
    reportedUsers?: UserReportUncheckedCreateNestedManyWithoutReportedInput
    sentMessages?: UserMessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: UserMessageUncheckedCreateNestedManyWithoutReceiverInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
  }

  export type MemberCreateOrConnectWithoutReceivedNotificationsInput = {
    where: MemberWhereUniqueInput
    create: XOR<MemberCreateWithoutReceivedNotificationsInput, MemberUncheckedCreateWithoutReceivedNotificationsInput>
  }

  export type PostCreateWithoutNotificationsInput = {
    board_name: string
    title: string
    content: string
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    board?: BoardCreateNestedOneWithoutPostsInput
    author: MemberCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    postActions?: PostActionCreateNestedManyWithoutPostInput
    images?: PostImageCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutNotificationsInput = {
    id?: number
    board_id?: number
    board_name: string
    title: string
    content: string
    user_id: number
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    postActions?: PostActionUncheckedCreateNestedManyWithoutPostInput
    images?: PostImageUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutNotificationsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
  }

  export type CommentCreateWithoutNotificationsInput = {
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    post: PostCreateNestedOneWithoutCommentsInput
    author: MemberCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
    actions?: CommentActionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutNotificationsInput = {
    id?: number
    post_id: number
    user_id: number
    content: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
    actions?: CommentActionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutNotificationsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
  }

  export type MemberUpsertWithoutSentNotificationsInput = {
    update: XOR<MemberUpdateWithoutSentNotificationsInput, MemberUncheckedUpdateWithoutSentNotificationsInput>
    create: XOR<MemberCreateWithoutSentNotificationsInput, MemberUncheckedCreateWithoutSentNotificationsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutSentNotificationsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutSentNotificationsInput, MemberUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type MemberUpdateWithoutSentNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    receivedNotifications?: NotificationUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUncheckedUpdateWithoutSentNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    receivedNotifications?: NotificationUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type MemberUpsertWithoutReceivedNotificationsInput = {
    update: XOR<MemberUpdateWithoutReceivedNotificationsInput, MemberUncheckedUpdateWithoutReceivedNotificationsInput>
    create: XOR<MemberCreateWithoutReceivedNotificationsInput, MemberUncheckedCreateWithoutReceivedNotificationsInput>
    where?: MemberWhereInput
  }

  export type MemberUpdateToOneWithWhereWithoutReceivedNotificationsInput = {
    where?: MemberWhereInput
    data: XOR<MemberUpdateWithoutReceivedNotificationsInput, MemberUncheckedUpdateWithoutReceivedNotificationsInput>
  }

  export type MemberUpdateWithoutReceivedNotificationsInput = {
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
  }

  export type MemberUncheckedUpdateWithoutReceivedNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    all_posts?: IntFieldUpdateOperationsInput | number
    authority?: IntFieldUpdateOperationsInput | number
    all_views?: IntFieldUpdateOperationsInput | number
    password?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutUserNestedInput
    commentActions?: CommentActionUncheckedUpdateManyWithoutUserNestedInput
    blockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    blockedUsers?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    reportedBy?: UserReportUncheckedUpdateManyWithoutReporterNestedInput
    reportedUsers?: UserReportUncheckedUpdateManyWithoutReportedNestedInput
    sentMessages?: UserMessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: UserMessageUncheckedUpdateManyWithoutReceiverNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type PostUpsertWithoutNotificationsInput = {
    update: XOR<PostUpdateWithoutNotificationsInput, PostUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutNotificationsInput, PostUncheckedUpdateWithoutNotificationsInput>
  }

  export type PostUpdateWithoutNotificationsInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    board?: BoardUpdateOneRequiredWithoutPostsNestedInput
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postActions?: PostActionUpdateManyWithoutPostNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutPostNestedInput
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentUpsertWithoutNotificationsInput = {
    update: XOR<CommentUpdateWithoutNotificationsInput, CommentUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutNotificationsInput, CommentUncheckedUpdateWithoutNotificationsInput>
  }

  export type CommentUpdateWithoutNotificationsInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    actions?: CommentActionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
    actions?: CommentActionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type PostCreateManyBoardInput = {
    id?: number
    board_name: string
    title: string
    content: string
    user_id: number
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
  }

  export type PostUpdateWithoutBoardInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    author?: MemberUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postActions?: PostActionUpdateManyWithoutPostNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutPostNestedInput
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PostCreateManyAuthorInput = {
    id?: number
    board_id?: number
    board_name: string
    title: string
    content: string
    views?: number
    likes?: number
    dislikes?: number
    reports?: number
    created_at?: Date | string
    updated_at?: Date | string
    url_slug: string
    user_nickname?: string | null
    is_deleted?: boolean
  }

  export type CommentCreateManyAuthorInput = {
    id?: number
    post_id: number
    content: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type PostActionCreateManyUserInput = {
    id?: number
    post_id: number
    action_type: string
    created_at?: Date | string
  }

  export type CommentActionCreateManyUserInput = {
    id?: number
    comment_id: number
    action_type: string
    reason?: string | null
    created_at?: Date | string
  }

  export type BlockedUserCreateManyBlockerInput = {
    id?: number
    blockedId: number
    createdAt?: Date | string
  }

  export type BlockedUserCreateManyBlockedInput = {
    id?: number
    blockerId: number
    createdAt?: Date | string
  }

  export type UserReportCreateManyReporterInput = {
    id?: number
    reportedId: number
    reason: string
    createdAt?: Date | string
    type?: string
  }

  export type UserReportCreateManyReportedInput = {
    id?: number
    reporterId: number
    reason: string
    createdAt?: Date | string
    type?: string
  }

  export type UserMessageCreateManySenderInput = {
    id?: number
    receiver_id: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
  }

  export type UserMessageCreateManyReceiverInput = {
    id?: number
    sender_id: number
    content: string
    isRead?: boolean
    createdAt?: Date | string
    is_deleted_by_sender?: boolean
    is_deleted_by_receiver?: boolean
  }

  export type NotificationCreateManySenderInput = {
    id?: number
    type: string
    receiver_id: number
    post_id?: number | null
    comment_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type NotificationCreateManyReceiverInput = {
    id?: number
    type: string
    sender_id: number
    post_id?: number | null
    comment_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type PostUpdateWithoutAuthorInput = {
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    board?: BoardUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    postActions?: PostActionUpdateManyWithoutPostNestedInput
    images?: PostImageUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    postActions?: PostActionUncheckedUpdateManyWithoutPostNestedInput
    images?: PostImageUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    board_id?: IntFieldUpdateOperationsInput | number
    board_name?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    reports?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    url_slug?: StringFieldUpdateOperationsInput | string
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CommentUpdateWithoutAuthorInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    actions?: CommentActionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
    actions?: CommentActionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostActionUpdateWithoutUserInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutPostActionsNestedInput
  }

  export type PostActionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostActionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentActionUpdateWithoutUserInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutActionsNestedInput
  }

  export type CommentActionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentActionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUpdateWithoutBlockerInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocked?: MemberUpdateOneRequiredWithoutBlockedUsersNestedInput
  }

  export type BlockedUserUncheckedUpdateWithoutBlockerInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockedId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockerInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockedId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUpdateWithoutBlockedInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: MemberUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockedUserUncheckedUpdateWithoutBlockedInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockedInput = {
    id?: IntFieldUpdateOperationsInput | number
    blockerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserReportUpdateWithoutReporterInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reported?: MemberUpdateOneRequiredWithoutReportedUsersNestedInput
  }

  export type UserReportUncheckedUpdateWithoutReporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserReportUncheckedUpdateManyWithoutReporterInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportedId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserReportUpdateWithoutReportedInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reporter?: MemberUpdateOneRequiredWithoutReportedByNestedInput
  }

  export type UserReportUncheckedUpdateWithoutReportedInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserReportUncheckedUpdateManyWithoutReportedInput = {
    id?: IntFieldUpdateOperationsInput | number
    reporterId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type UserMessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
    receiver?: MemberUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type UserMessageUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserMessageUpdateWithoutReceiverInput = {
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
    sender?: MemberUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type UserMessageUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserMessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    is_deleted_by_sender?: BoolFieldUpdateOperationsInput | boolean
    is_deleted_by_receiver?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUpdateWithoutSenderInput = {
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: MemberUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    receiver_id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    receiver_id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutReceiverInput = {
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: MemberUpdateOneRequiredWithoutSentNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sender_id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutReceiverInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sender_id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableIntFieldUpdateOperationsInput | number | null
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: number
    user_id: number
    content: string
    parent_id?: number | null
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type PostActionCreateManyPostInput = {
    id?: number
    user_id: number
    action_type: string
    created_at?: Date | string
  }

  export type PostImageCreateManyPostInput = {
    id?: number
    image_url: string
    created_at?: Date | string
  }

  export type NotificationCreateManyPostInput = {
    id?: number
    type: string
    sender_id: number
    receiver_id: number
    comment_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    actions?: CommentActionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
    actions?: CommentActionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PostActionUpdateWithoutPostInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: MemberUpdateOneRequiredWithoutPostActionsNestedInput
  }

  export type PostActionUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostActionUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageUpdateWithoutPostInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostImageUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    image_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutPostInput = {
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: MemberUpdateOneRequiredWithoutSentNotificationsNestedInput
    receiver?: MemberUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    comment_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentInput = {
    id?: number
    post_id: number
    user_id: number
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    likes?: number
    dislikes?: number
    user_nickname?: string | null
    is_deleted?: boolean
    deleted_at?: Date | string | null
  }

  export type CommentActionCreateManyCommentInput = {
    id?: number
    user_id: number
    action_type: string
    reason?: string | null
    created_at?: Date | string
  }

  export type NotificationCreateManyCommentInput = {
    id?: number
    type: string
    sender_id: number
    receiver_id: number
    post_id?: number | null
    is_read?: boolean
    created_at?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: MemberUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    actions?: CommentActionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
    actions?: CommentActionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    post_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    user_nickname?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentActionUpdateWithoutCommentInput = {
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: MemberUpdateOneRequiredWithoutCommentActionsNestedInput
  }

  export type CommentActionUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentActionUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    action_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutCommentInput = {
    type?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: MemberUpdateOneRequiredWithoutSentNotificationsNestedInput
    receiver?: MemberUpdateOneRequiredWithoutReceivedNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    sender_id?: IntFieldUpdateOperationsInput | number
    receiver_id?: IntFieldUpdateOperationsInput | number
    post_id?: NullableIntFieldUpdateOperationsInput | number | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}